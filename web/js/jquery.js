/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function(e,    t  )  { "use st ric t";  "o bj ec t" == t yp eof  mo  du le &&  "o bject" == t y peof modu l e. e xports ? m o  d u le. e xport s  =  e  . do c ument ?  t(e ,  ! 0) : function (e) { if (!e.document) throw new Erro r("jQuery r e q uire s a wi ndow w it h a   d ocum  e nt");  r eturn   t (e) } :  t ( e)  } ("unde  f ine d "   ! =  typeof  wi n dow ? wi n d ow  : th i   s , f  u  n ction(C,   e) { "use str i c t";   v ar  t   = [ ] ,  r  = Object.g e tProto ty pe O f , s = t . s  l i ce, g   =  t. f   l at ? func t i on(e) { return  t   . f l a t.cal l (  e )  } : funct   i  o  n ( e )   { ret u rn t.  c o ncat.a pp ly([], e )    } , u  =  t.pus h ,  i = t. in dexOf,   n    =  { } , o =  n. t o S t ring,   v  = n.hasO w n  P ro p ert y ,  a =  v . t o St ring,  l   =  a.ca ll(  Ob  jec t), y  =   { }, m =  fu nc ti on ( e ) {  r et u rn  "  fu n c ti o n "  = =  t yp e of  e && "nu mb  e  r " !=   ty pe of    e . no de T  ype    &&  "fu nction  "  ! = typeof  e. it  e m }, x = fun ct i o n  (e) {  re t u rn   n ul l != e && e === e.wind o w },  E  = C. d o c um en t ,    c   =  {   ty pe :   ! 0,  s rc :  !0, nonce:    ! 0, noM o dule: !0 };   f  unction   b(e, t,  n  ) {    var r, i ,   o = (n = n  ||   E).createElement("scri  p  t" ); if (o.te x   t = e ,  t)  f  or   (  r    in    c) (i  =    t[ r ] || t . ge  tA ttrib ut e  & & t .ge t A  t  tr i bu te(r))   &&   o.setA t  t   r ib u t e(r ,   i );   n  .head.ap p   e  ndChil d( o). pa r ent No de.remo ve Child(o)   }  fu nc t ion w(e) {   retur  n   nu  ll  == e ?    e +  ""  :  "o b j ec t "  == t   y p e o f  e | |   "f uncti o n  " == t yp  eof   e   ?  n[ o .c  a ll(e) ]   ||  "object "  :   t yp e  o  f e } v a r f  =  " 3 .6.0" ,  S    =   functi on  ( e, t) { ret ur n ne w  S  .f n .init(e , t )  }; fu n ction p(e) { var t  =  ! !e  && "len gt h "   in e && e.l  en  g  t  h,  n = w (e);   r e   t u rn !m( e ) && !x(e) & &  ("arra  y"  === n  ||   0 == = t ||  "  n umbe r " == typeo f  t &&  0 < t && t    -  1 in e) } S.fn  =  S. p  rotot y p e   = {  jquery: f,  c onstructor: S , leng th :    0 , t oA rr a y:   f un  c  tion () { retur n  s.call(this) }, g et: functio n(  e ) { retur n  n ull  ==    e   ?    s.  call(t his)   : e <     0 ? this[e   +  t h is . l e n g th]  : this[e]  }, pushSta  ck   :  f u n c  tion(e)  {   v  a r t  = S.merge( t h is .cons tructor(),     e); return t.prevO  b j ect  =   thi s, t }  ,  each : functi on (e) { re t urn S.each  ( this, e) }   ,  m a p:  f u  nc  t   i o n ( n)  {   r etu   r n  t h is.pu s hStack(S. m a p(t his , function (e , t)  {  re tu r n  n .  ca l l(e, t ,   e  )  })  )  },   sl ice: fun c  t io n( )     { r e tur n  t hi   s . p u s h S   t  a c k  ( s.a  p pl y (this, argumen ts) )  },    f i  r s  t :  functi on  (  )   {   r  e tu r  n  t his.eq( 0 ) }, last :  fu n ction()  {  return   th i s.eq( - 1 )    } , eve n:  func  t io n ( )   { retur n this.p  u s   hSt a c k(S  . g r ep(this,  f  u nct i on(e,    t )  {  r et   ur n   (t  +     1 ) % 2 }) ) },  o  dd:   f  u n  c  t ion() { return th i s .pu  shS  tack(S.g re  p( thi s, fu nc ti   o n( e ,  t) { ret ur n  t   %  2 }))    },  eq:  fu nctio n(e )  { va   r  t   =   thi s  .le  n  gt h,   n = + e  + (  e   <  0  ?  t  :   0);   r  et u rn th is .pushS t  a ck (0 <=  n  & &  n <  t  ?  [this[n ]]  :    [ ] ) } ,   e  n d  :  f un ction( ) { return  t h is . p r  evObjec t || t his .c o n s  t  ructo r ( )   } , push:  u ,  s ort:    t .s  o  r  t,  sp li ce :  t.spl ice  } ,    S. e  x t e n d    =  S . fn . ext en d  =  f unc   t  i on()   { v  a  r  e, t,   n ,  r , i,  o,   a   = argu ment s[0 ]  ||   {} , s =  1 ,   u   = arg uments .length,  l  = !1;  fo r  ("boolea  n "   ==  t y p  eof  a && (l    =  a ,  a = arguments   [s ] ||  { }, s++),    " ob jec t " = =  t y peo f a | | m( a )    || (a   =  {}), s   = ==    u  && (a =  t h i s,   s- -);  s  <  u ;  s+ +)  if ( n ull  !  =   ( e = ar g um en ts[s ] )  )     f or (t i n    e ) r = e[t] ,  " __  proto__" !== t    &   &  a !==  r  &&  ( l    &&   r & & (S.i s P l a i nO b j ect( r )  | |  (  i   =   Array.i sAr ra y ( r )  )) ? ( n  =   a[t], o  =  i  & & !Array. i s  Ar   r ay(n  )     ?  [ ]   :    i  ||  S.i  s P  la in Ob j e c  t(n) ? n  :    { } ,  i  =  ! 1  ,   a [t ] =  S. e xt e nd ( l , o,  r ))     :  v  oi d 0    !==  r  &&  (a[t] = r  ))  ; re tu  rn a  }   , S .exte nd({  e xp an do:  "j  Q uery" + (f  +  Math.r  a ndom( )).repla ce (/ \D/g, "" ), isReady:  ! 0 , err o r :  fun ction(e) {  th r ow  new Error(e)   }, noop: f  unction( )    {  }, isP l ai n   O  bj  e  ct: funct ion(  e  )  {  v ar t,  n; r e turn   !(  ! e     ||  " [o bj ec t   O  b  j  e c  t  ]"  ! = =  o. ca l l   ( e )) &&   ( ! (t = r(e) )     |  |   "  f u ncti  o   n" ==   t ype o   f   ( n      = v.call(  t  ,   " cons tru c to  r   ") & &    t . constructor)   &&      a.  c a ll( n)   = == l) }   ,   is E  m p t yObjec   t  : f u n ct  i   o n (e) {  v a  r     t;  f o   r    (t in  e) re t u r  n ! 1 ;   return  ! 0  } ,   globalEv al : fu nction(e, t ,  n)   { b(e,  {   n on c e : t  & & t.no nce  } ,  n) }, ea c h :  function (e ,  t ) { var    n  , r  =  0; if (p( e))   {  fo r (n = e .len gt h;     r   < n;  r+ +)i f  (!1 === t. call(e[r],  r,    e [r] ) )     brea k   }    els   e   for (r i n  e)  i f   (!1 ===  t .call(e[r], r, e[r]))  b reak; return e }, ma k e A r ray: f u n c tion(e,   t ) {  v a r  n = t || []; return null != e && (p(Object(e)) ? S.merge(n,  "string" = =  t ypeof e ?   [ e  ]   :  e)  :   u . call(n, e)),    n   }, in   A  rray: funct i   o n (e,  t,  n )  {  re tu rn  n  u l   l  ==   t   ?    - 1  :  i. ca   l   l (t ,   e , n )      } , merge:  f   u   nction(e,  t   )     {     f o r     ( v ar n  =     +t.le   n  g th, r   =   0 ,  i   =  e.leng t h ;   r   <     n;  r++) e[i + +]  =       t[r]  ;  r e  t urn e.length =  i ,    e    },   g r ep: fu n c  t i o n(e,   t  , n)  {  f o r (var  r     =  [],  i = 0,  o   =  e         . l   engt h  ,  a   = !n; i <   o ;  i++)!t (e[i] , i )  !== a &&  r.push (e [i   ]   ) ; return r }, map: function( e ,   t, n) { var r ,   i , o = 0, a =   [ ] ; if (p(e )) fo r (r  = e.length; o < r ;   o ++)nu ll !=  (i = t(e[o],   o ,  n)) &&  a . p ush(i); els e   for (o in e) null != (i =   t ( e[ o ] ,  o, n)) && a.push( i ) ;  return g(a) },  g  u id :  1   ,   s upp o   r t :  y }),   " f unction" == typ e o   f   Symbol  & &  (S.fn[Symbol.iterator] =   t [Symbol.iterator]), S . e a ch("Bo  o  l  e an N um b  e r  Str i n g  Function Array D a t e  RegExp Object Error Sy mbol" .s p lit(" "), f un c tion( e , t)   { n["[obje c  t   "   + t +  "] "]   =   t . t oLowerCase()    } );  va r  d   =  function(n) {     v   a r e,  d,  b ,   o, i, h ,  f,   g, w,  u ,   l, T,  C, a ,   E, v, s, c, y,   S   = "s  i   z z le" +    1    * new D a te,  p     =    n.doc u ment ,   k   =    0 ,     r = 0 ,   m = ue(),   x  =  ue(),   A    =  u e(),   N  =  u   e ( ), j =   fun ct io   n ( e , t)  {     r etu  r n e  === t &&  (l    =   !0) ,   0 }, D  = {}.hasOwnPrope r  t  y ,   t =  [],  q  = t. pop, L =   t  .  p  ush, H =    t.pus h, O = t.slice  ,  P  = funct  ion(e, t) { fo r  (v ar n =  0 ,  r =  e.l e n g t h; n <  r; n++) i f (e[n] ===  t )  return n;  return -1   } ,   R   = " ch e cked| s elected|a s y nc |auto  f o c  u s|autopl ay|c o n   t   r o l s |defer|d i s a  b le d| h idd en |i s  ma p| l  oo p | m ul tiple|open | r e   a d o nl y|req u i re d| sc o p ed " ,  M = "[\ \x 20\ \ t  \  \r \\ n \\f ] ",   I =   "( ?: \\\ \[ \\da-fA-F ]{ 1,6 }"  + M +   " ?  |  \  \  \ \[ ^\\ r\\ n \\ f] | [\\ w - ] | [^ \0 - \\x7f ] )+ ",  W   =   "\  \[  "    + M + "*( "   + I  + ")(?:"  +  M + " *([ *^ $|!~]?=)" + M   +     "*(?:'( (  ?  :  \ \\\.|[^\\\\'])*)'|\" (( ?: \  \  \ \.|[ ^\\ \\ \"])*)\"|(" + I +   " ))|) "    +  M   + "*\\ ]" ,  F =  ":(" + I + ")(?:\\((('((?:\ \  \  \ .   |[^\\ \\ '])*)'|\"((?:\\\ \.|[^ \ \  \ \\"])*)\")| (( ? :\\\\  . |[^\ \ \\()[\\] ]| "  + W +  ")*)|.* )\ \) |  )   "  , B =  ne w Re g Exp( M  +   "  +", "g " ),  $  =  ne w  R egExp("^ "   +  M   + "+|( (?:^ | [ ^ \ \ \\ ]) (  ? :   \\   \ \ . )* )" + M + " +$ ", "g"), _  =  n e w RegExp(" ^"  + M + "*,"  +    M  +  "* " ),  z  =    n ew  R egE x p("^ " +   M  +   " * ([> + ~]|" +  M +    ") "  + M   + "*"),   U  = n e w  R e gEx p (M + "| >"),  X =    new      R egE   x   p (F ),     V =   new Re g  E x p (" ^"   +   I +   "$"), G  =  { ID:   n ew  RegExp("^# ("   +   I + " )"  ) ,  C LAS S : new R e g Exp ( "^ \\.( "  +  I +  ")"), T A G :  n ew Re gExp("^( " +   I  +    "| [* ] )") ,  ATTR:  n ew Re g Exp ("^"  + W), PSEUDO:   n e w RegExp("^" +  F ), C H ILD: ne w  Re gE  xp( " ^ : ( only|f  irs t |las   t   | nth|nth-la st  )  -(child|of   -ty p e )(?:\ \ ( " +  M  + "* (  ev e n|odd | (([+-]|)( \ \  d*  ) n|)"   + M +    " *(? :([ + - ]|)"  +   M   +     " * ( \ \d+) |) )" + M +  " *\ \) | )", "i " )   ,  b o   ol :  ne w   R  e g  Exp( " ^(?:" + R +     "  ) $ ", " i"),  n e e d sC on t e xt : n   e w  RegEx p( "^"  +  M   +   " *  [ >  +   ~ ]|   : ( e v en| o  dd   |e  q|g t| lt| nt h|fi rs t|l a s  t)(?:\ \ ( "   +   M   +  " *(  ( ?:  -\\ d  ) ?  \\ d *)" + M  +  "  *\  \)  | )(? =[  ^ -] |$  ) " ,    "  i ")  },  Y   =  /HTML$/i, Q = /^( ?  :inpu t|se le  ct |te xta re a|button)$/i,  J  =   /  ^h \ d $ /i ,  K  =  /  ^ [^{]+\{\s*\[native    \w / ,  Z  =  / ^(?: #([ \w -]+) |(\w+) |\.([\w  - ]   +) )$ / ,   ee  =  /  [+~]/,  te   =   new R egExp("\ \ \\[\\da-fA-F]{1,6}   "  +   M +    "?|\ \  \\ ([^\\r\\ n\ \f ])" , "g"), n  e   = fun ctio n (e, t)  { var n  = "0x"   + e.slice( 1) - 65536 ; r e t urn t || ( n <     0   ?  Strin g . f  r omC h arCo d e ( n   +   655 36)   :  St ri ng  .fr   o  mC har Code (  n > > 10 |  55 2 9 6 , 1023 & n | 5   6 32 0) )  } ,   re     = / ( [\   0-\ x1f\x7f ]| ^-? \d ) |^-$|  [   ^\ 0  -\x1f\x7f - \ u   FFFF\w-]/ g, ie  =  f  un   cti o  n ( e,  t ) {  r   etu r  n  t  ?  "\0" === e ?  " \ u f f  fd " : e.slice  ( 0,   -1) + "\\" + e.charC o d  e A t ( e  . le n   gth - 1).t o St  r i ng( 16)  +   " "   :   "  \\"      +    e }, oe =   f u n   c  tion() {  T ( )  },  ae = b e (fu n cti on(e)  { return   ! 0  = == e.disab le d && "  f  i   eldse t"  = ==   e .no d eNa m e.t o  L  o w e   r Ca se() }, {  di r :  " parentN  o  d  e   ",  next: "leg en d" });  try {  H  .a  p p  l   y(t = O.call( p .ch i l  d Nod   es ) ,  p. c hildNodes),  t [  p .ch ild N od es.len g th]. n ode T ype } cat ch  (e) { H = { ap ply :   t .l e ngth   ?     f unction(e, t)  {  L.ap ply(e ,   O.c   a l l(t)) } :  f unc t ion(e ,  t) { var n = e.length, r =  0;  w hile ( e[n+ +]   = t[r  ++ ] ) ; e.le ng t h = n -    1  } } } func ti on se(t, e, n, r) { var i, o ,   a , s  ,   u, l, c ,  f = e  & &  e . ow n erDocument, p     =   e ? e.no deTyp e : 9 ; if ( n =  n || [],   " s tring"   != type of   t   ||  ! t  | |  1   ! ==   p & & 9 !== p  &&    11  !== p) ret ur n n; if (!r &  &   (T(e), e = e  ||  C,  E) )  { if  ( 11  !== p  & &  (u = Z.e xec(t ))  )   if  (i  = u[ 1  ])  { if (9  = = =  p )   {  i f (!(a = e . getElem en tById(i)) )  retur n n; if  (a  .i d === i)  r eturn n.push   (a ), n }   e l s e     if (f && (a  =   f .getElementById( i ) )  && y ( e, a) && a.id = ==  i )  r etu rn n. p  ush(a),  n  }      el se { if   (u [ 2] )  return  H. a p  p  ly ( n, e. g etEle m entsByTagNam e(t)),     n;  i f    (( i  =  u[3] )   & & d.getEle  m e nt  s By ClassName   & &  e.get Elem e ntsB y Cl as s Name) retur n    H.apply(n, e.getEleme n ts  B y ClassName( i)) ,   n  } if (d .q s a & &   !   N [t  + " "] &   & ( !v  | |  ! v .  tes t ( t))  &&  (1  !==   p  || "ob je ct  "    !== e .n od e   Nam e . t oLowerCase () ))     {  if   (c = t, f = e, 1   === p  &&    (U.  tes t( t) ||  z.t  e s  t (t)))  {   (f =  ee. t e st (t )  &  &    ye(e .p are   ntNod e) ||  e)   === e   &  & d.s c  op e  ||   ( (s  =   e. g e  t  At tribute("i d " ) ) ? s =  s. replac e (re,  i e)  :  e .setAt tribute("id ",  s =  S ) ) , o  = (l =   h(t ) ).leng t h;  w h ile (o--   )  l[ o ] = (s  ?  "#"  +   s    : ":s c o pe") + "    "     +  xe ( l [o] ) ;  c   =  l. jo in(",") } try { ret  u rn H . a pp l y(n,   f .  q ue r y Sel ector Al l (c )),  n  }    catch  ( e) { N(  t  , !0) } fin  a  lly {  s  = = =   S &&  e. removeAt tr  i   b  ut e("id")   }   }  }   ret urn g(t.re pl ace($ ,  "$ 1"), e,  n,  r )  }   function ue( )  {   var      r   = [];     re t ur n  f unction e(t,  n  )  { ret urn     r. pus h(t + " ") > b.c a cheLeng t h && dele t e   e[r.shif t() ],  e [ t   +  " "] = n  }  } function le(e) { retur n e[S ] = !0,   e } functio n c e (e) { var t = C.createElement("fieldset");  tr y { return !!e(   t )  } catch  (e ) {  return !1 } finally {  t .parentNode & &  t.parentNode . r e moveChild(t) ,   t  = n  ull  } } functio n  fe(e,  t )   { va r  n =  e. split("|"),    r   =  n.length; while (r--) b.attr Han dle[n[r]]  = t  } functi o n pe(e , t) { v a r n = t && e, r = n && 1 == =  e.nodeType & &     1 === t . n o deTy p e   && e.sourceIndex   - t .sourceIndex; if (r) ret u rn r ;  if (n) while (n = n .nextSib ling) if  ( n  = = =  t) retur n   - 1; return e ? 1 : - 1 } f u nc tion de(t) { ret urn  fu nction(e) { r etu rn "input" ===    e. nodeNam e . t oLowerCase()   && e.type = = = t }   } function he (n)  { return function( e ) {  var  t  = e.nodeName.toLo wer C  a se (); retur n  ("in put" = ==    t  || "button"  == = t) && e.type = == n  }  }  fu n ction   ge(t) { return fun ct  ion(e) {   r e t   u rn   "f o rm"   in  e ? e . parentNode  & & !1  = == e.di sa bled  ? " label" i n e ? "lab e  l" in   e.parentNod e  ?  e .pa r ent Node.disabled = ==  t : e.disabled ===  t  : e .isDisab le d  === t  ||    e .i sDisabled   !== !t &&  a e( e )  ===  t :  e.di sa bled === t   : "label "  in  e  &  &   e.dis ab le d   === t  }  } function v e( a)   {   r etu r n le(fun ct ion(o) { return  o  =  + o,  le( fu nct i on (e,  t )  { var  n , r = a([ ], e. l e n gt  h, o) ,  i  =  r.le ng th;     wh i l e (i--)  e[ n = r[i]] & &  (e[n] =   ! (  t[ n] =  e  [n] ) ) }) } )  }  fu n c t ion ye( e ) { return e && "undef i   n e d"  != typ eo f  e.ge t  ElementsBy T  a g Nam e   &&  e } for (e   in d = se. s uppo r t  =   { },  i = se.isXML    = fun  c  t io n(e)  {   var  t = e & &    e.nam e s pa c eURI, n  =  e    && (e . o wne r D oc u m  e nt   || e).documentElement;  r etur   n  ! Y. t est (t    |  |   n &&  n   . nod eName | |  "  HT  ML ") },  T   = se.s et  D   o c u ment  =  fu nc t io n( e)   {   var t,   n,  r  = e ?   e.own er Document ||  e    :   p; return r  !=  C && 9 = == r.nod eT yp e  & &  r.doc um en tEl em en t  && (a = (C = r). do cu m entE le m e nt,   E  =  !i(C ) ,     p != C && (n =  C. defaultVie w)  && n.top !==  n     & &  ( n .  addEventListene r  ?  n .add Ev   e  n t Li s te ne r ( " unload ",   oe , !1 )  :   n   .  a t  t a chEv en t   & &   n . at t ac h E vent("onunl oa d ",  o e)) ,  d.scope  =  ce (f unctio n   (e )   { return a.ap p e ndChild(e).ap p e ndCh i l d(C. cr eat  e E l ement("d iv " ) ),      "   u   n d e fi n e d "   ! =  typ  e o f e. qu e ry Se le cto rA ll && !e.que ryS e l ec  to r Al l (":scope   f  i eldset div" )   .  l e n gt h   }), d.attri butes = ce(fu nc t  i o n (e)  { re tur  n  e.cla s sName =   " i  " , !e .g e t At t ribu te ( " c l a ssN a me ") }), d.g e tEleme ntsB  y T agName = ce( fun c tion( e)  {  return e.appendCh i ld(C.crea t e  C om ment(" ")) ,   ! e.getEl  e   m  e nt s B y  T  a g Na me("*").len gt  h  }) , d.getEleme nts B yClas s Name = K. te  st  ( C. getElementsByCla ss Na me), d.get By Id  =  ce ( f u nction(e) {   re tur n  a.ap pen d Chil d(  e ).id = S ,  !C.g et Eleme ntsBy Name  ||  !C.getElem e nt sBy Name (S ) .lengt h   }), d.getBy  I  d  ?  ( b. filte r.ID  =  f unction ( e) { var t  =  e .replace(te, ne) ;  re tu r n  funct ion(e )  { ret urn e . getAttribute("i d " )  = == t  } }, b.find.ID  = funct ion(e,  t )  {  i f ( " undefin ed" != typeof  t. g e t E lem entBy Id  & &  E ) { var n = t.get E le m entById(e );  return n  ?  [ n ]   :  [ ] } })  :  (b.  f  ilt er.I D  = function ( e) { v ar   n = e.repla ce  (te ,  ne); ret u rn f unctio n (e) {  var t = "undefined" != ty p eof   e.g etAttributeN o de  & & e.getAttrib u teNode( "i  d "); re t u rn  t   &&   t  . va lu e  === n  } }, b.find. I D  = function(e  ,  t) { if (" un defi ne d"   != ty pe o f t.g e   tEl emen t  B  y Id && E)  {   var  n, r , i, o = t.get  E l  ementBy I d(e);   if   ( o)  {  if  ( (n = o.getA t t ri b u t eNo d e (" i d ")) && n. v a  lue   == =  e)  r et   u r n  [ o] ; i  =   t. getEl e m en tsByNa me(e) , r = 0;   while (o = i[ r++])  if  ( ( n  =  o. g e  tA t t ribu te Node("i d" )) & &  n.valu e  = =   =    e)  re tu rn  [o] } retur n  [] } }),  b  .  f ind. T AG  = d. getEleme nt sB y TagName ?    f   u nc tion(e,  t)  { retur n  " und efined  "   ! = typ e  o  f t . get Elemen t  s ByTa g Name  ? t.ge t El  e m e  nt  s ByTa g Name (e)  : d.qsa    ?  t   .q u ery Se l ect orAll (e) :   v  o id 0   } :  fu n ction(e, t)  {     var n, r  =  [],  i = 0, o =    t .g e tEle m entsByTagName(e) ; if  ("* "    =  ==  e)  {  whi  le    (n  =  o[i++  ])    1  ===  n.n od eT yp   e   & &  r .  push (n );  ret ur n   r  }    r e t urn   o }, b. fi  n  d. CL ASS  =  d.ge tEl e  me n ts ByCla s  sN a me &&  f unction(e, t) {   i  f  ("und e fine d " !=  ty pe o f   t. getE lem e nt  s B y C l a  ssName  &&  E ) ret  u r n   t . get Ele mentsB y Cla  ss  Na m e(e) }, s   =  [], v =  [], (d.q s   a  =   K . test( C. query S el ectorAll)) && (ce(fu n ctio n (e )  {    v   a r   t  ;   a. ap p e nd Child(e ) .  i  n n er HT M L     =   " < a  i d=  '" + S +   "' > </a >< s  el  ect    id = ' "   +   S  +  "   - \r\\ '   m s  a l l o w  ca  p  t u r e = ' '><o ption  s e  l e ct  e d= '' ></opti o n ></ se lect>"  ,   e.  q  u e r y SelectorAl   l ( "[ ms a l lowcapt u r   e^=' ' ] ").l en  gt h  & & v .push("[ *^ $ ]  ="      +   M    +   " * ( ? :  ' '  |  \  "  \ "  )"),  e  .  qu e r yS e le ct or  A l l  ("   [ s ele c t e d]") .l e  n g  th  || v .p   u sh("\\[" + M  + "*(? :v alue| "   +  R + "  ) " ) , e.que ry Sele ctorAl l( "[id~ =" +  S + " -]"  ) .len gth  || v.pus h (" ~= "),    (t  =  C  .cre at e  E  le   m ent( "i n p u t  "  )).  s  et Attrib ute ( " name",  "" ) ,   e  . a p p en dC hi ld ( t ),  e . q u e r y S   el e cto r A l l(" [ n ame= ''  ]   " ). l eng th | |  v .p   ush( "\  \ [ "  +  M   + "*name"  +     M   +  " *   =  " +  M  + " *( ?:' '|\ " \ ")"  ),    e .  q u er y SelectorA ll ( "  : chec k ed").len g  th   ||    v  . p u s h( ":checked" ), e. qu   er ySe l e cto r A  l l ("a  #" + S + "+ *" ). le ng t  h ||   v.p u  sh (". #.+ [  +~] "   ),  e  .qu erySe l ecto r   Al l("\\  \f" ),  v.pus h ( " [ \\ r \\n \ \ f ] ") }),  c e(f un  c tion(e ) {  e . innerHTML   =   " <  a  h  re  f =' '   d i s a  bl   e d ='disab l e d '></a><se le c t d i s abled='disa b l   e d  '> < op tion/ ></se l ect > " ;  va r t   =  C. cr eat e El eme n t ( "  i  n p   ut "); t .s e tAttr ib ut e  ("type", "hidden " ), e  .a   p p e n  dChild( t) .setAt tri b u   t e( " n  a  m  e ",  " D"), e. qu er   y Sele ct o rA ll ( "[ n am e =d ] ") . length && v.p u sh (" n   a m  e "  +  M   +  " *  [  *^$| !~ ] ? = " ),  2  !== e.qu  e  rySelectorA l  l (":en a b  l ed") .le n gt h &&   v .p us   h ( ": enab l ed", ":di sa b  le d "),  a . ap pend Ch il d ( e ). di sabled =  ! 0,  2  !== e.quer yS ele c  t  or  A l  l(" : dis ab led " ) . l e ngth &&    v  .p u s h (  "  :   en a  b   l ed  "  ,  "  : d is a bled"), e .q uerySelec t o  r All("*, :x "),  v  .p u sh (",.*:  " ) } )) , (d  .m   a t ch e s  Se l  e ct o r   =     K.t est(  c   =    a .matches ||  a.we bki tM  a t c hes Selector  |  |   a .m oz Ma  t  c he s S e  le  c t  o r || a.oM a tche sS elect o r || a   . m sMa   t c  he  s  S  ele ctor))  & &   ce (  f  un  c t  i o n  (   e)      {   d   .  d i sc on n ec t ed M at c h = c  . c  all(e, "*") ,  c.call(e , "[s!='']:x"), s.pu s  h(" != " , F) }), v =  v. l e n g th  && new Reg  E x p( v .   j oin("| "  ) )  ,  s    =   s  .le ng th && new RegExp(s . join("|")) ,  t    = K.te s t( a .c o m pare D o cu m e n t   P osition ), y   =    t | |  K.t est( a . c onta i ns) ?  f u  nct ion(e,    t ) { var  n  =   9     = ==  e .no d e Type  ?  e .doc u m e nt El e men t   : e ,    r = t  &&  t  .par e  ntNo de; re t urn e  = == r     ||  !   (!r ||   1  !==  r.no d  eTyp e    ||  ! (n .c o  ntai  ns   ? n.c on tains ( r )  :    e. co m pare D ocum e  nt P osition  &  &  1 6 &  e.co  m  par eDoc u mentP osi tion   (r) ) )   } :  fu ncti  o n (e,  t)  { if (t )  while   ( t  =  t. par en t N o d e) if    (t  = == e )    retu rn  ! 0; ret ur n   !1 } ,  j = t ?  f un c t io n (e, t)  {  if  (e  === t) retur n  l  =   !0 ,  0; var n =  ! e  . compa re Doc um ent Po sitio n -  ! t.comp a reDo c  u men t   Po si t i o n ; retu rn  n ||  (  1 & ( n =    (e.own  e r Do  c   u m ent  |   | e)  = = (t. own erDocu m  e nt  ||  t) ? e.compare  D oc u me n tPo sition(t) :    1 )  | |   !  d .sort De   tach e  d &&  t. c ompareDocumen tP o s i  tion ( e) = = =  n  ?     e  ==  C   ||  e. ow  n  e rD   ocument =  =   p  & & y( p, e  )  ?  -  1  : t == C | |   t.ow ne rD o  cu m ent ==   p  &&  y (p,      t) ? 1  : u ?  P(u   , e)   -  P( u, t)  : 0  : 4  &  n ?  -1  :   1  ) } : f u nc ti  on(e, t)  {   i f  (e   = == t) re tu rn  l =  !0, 0;  var n,  r  = 0,   i  = e .  p arentNod e ,   o   = t. pa r e ntNode, a =    [e],  s = [t] ; i f    (! i || !o)  r eturn e  ==  C  ?   -1   :  t   = = C  ? 1  : i ? - 1   :  o  ?  1  :  u ?  P (u , e)  -  P( u , t) : 0; if  (i   =  = =  o)    r  e tur  n   p e(e,   t)  ;    n =  e; while  ( n     = n.parentNode ) a.unsh if   t( n); n  = t ; whil e   (  n = n. paren tN od e ) s.un sh if t(n); while ( a[ r] ===   s [r]) r++ ;  return r ? pe (a [r] ,   s[  r]) :   a[r] == p    ?  -1   : s[r] == p ? 1  :   0  }),   C  }, se. m at ch e  s = functio n( e ,  t)   { r e  t ur n   se   (e  , n ull  ,  n u l  l  , t )    },  s  e .m a  t c hes S e   lect o r  =    f un c  ti o n(e, t) { if   (T(e ),    d . m  at  ch e s Se lecto r  &&     E &&  !N [ t   +  " " ]  && (!s  ||  !s. tes t ( t))    &&  (  ! v  | | !v .   test(t )))  tr  y {   v ar n = c.ca ll ( e ,  t );    i f    (n   | | d . di s co nn e cted M at c h   | |      e . d oc u  m ent & &  1 1  ! = =   e.docu m en t .  n o  d e Ty pe )  r etu r n  n }   ca  tch (e) {  N( t  ,     !0) }    re t   ur n  0  < se(t ,    C, null,   [ e]  ). length } ,  s  e  . c o  nta i   n   s   =   f u n c t i o   n  ( e,  t)  { return ( e.o w n  erD ocu ment  ||  e )   ! =  C   & &  T ( e   ) ,     y   (  e  ,    t)   } , se.a ttr = f  u  n ction(e, t) {  ( e. o w nerDoc u ment |  |    e )  !=  C  && T( e);  var n =  b.a  t t r H  an  dle [ t .to   Lo wer  C  as e( )  ] , r  =   n  & &     D . call( b. a   ttrHa  nd le ,  t.to L o werCase()) ? n ( e,   t,    !  E   )  :  void  0 ;  re   t ur n v o id    0   ! ==  r ?  r    :  d .a tt rib ut es   || !E     ? e. g e  tA t t r   i b  u  t e   (  t) : (r = e.  g  et A t trib uteNo d e( t)  )    & &  r . s  p  e c i f i  e  d  ?    r. va  lu e : n u  l l  }, se.escap e   =   funct io n ( e) {  r etu rn  (   e  + " ") .  r e p l  ac  e (re ,   i e )  } ,   s  e  .e  rr or = funct io n(  e ) {   t h r  ow  n e  w   E rror ( "  S y n t  a  x   e r ror, unr  e c  og  n i z  e d ex pr ess i o  n:  "  +  e)  }  ,   se. u niq ue   Sor  t  =   f u  n ction(e )  {  va r   t   ,   n   =     []  ,    r     = 0,   i   =  0;    i  f (l  =  !d .detect Du  p licat es , u =    ! d.s o rtS  ta  bl e &&   e.   s li c e( 0 ) ,  e .so rt (j ) ,  l)    {  w hi l  e   (t =  e [ i  +  +  ] )    t  === e[ i]  &  & (  r   = n.push (i ));  while  (r - -)   e  .   s pl i  ce(n[r], 1)   }   r e  tu   rn   u  =   n   ul  l   ,  e    },  o =    s  e.g et Te x t  =  func  t i on( e)  {  v ar t,     n  =  "",   r =    0,   i  =  e.n  odeTyp e ;  if  (i )  {   if    (  1   =   = =  i    | |   9    =  =  =   i    |  | 11  ==  =   i) {  if (  "s t ring"  =  =    ty p eof e. te  x t   Con t e nt)   r eturn e.t e x t Co ntent ;  fo r  (e   = e .first C hi l d ; e; e =  e   .  nex tSibl ing)n   +  = o( e  )    }  els e i f  ( 3    ==   =   i |   |  4    == =  i )   r eturn  e .n od eVa l u e   }  e ls e   w h il e  ( t  =      e [r ++ ])  n + =  o  (t  )  ;   r etu r  n   n }  ,  (  b     =  se.sele  ctors   = {    c ac h  eL en gth:  5  0 , crea   t e P se u d o  :    le ,  m at ch:       G,  a t trHand le  :  { } ,    f   in d:  { }, r e lati   ve:  { ">":   {  d  i  r:   " p  a ren t  N ode  " ,   f i rst:  !0  } ,    "   " : {   d i r: "p ar en t  N ode" } ,  "+ " :   {  d i  r:    " p r evi o u sSi b ling" ,    fi r s  t :  ! 0  },  " ~  ": {  dir :   " p  r eviou sS ib l in  g " } } ,     p r e Fi l te r :  { ATTR :  fu n ction( e )   {   r et urn  e[1]    =     e [ 1  ] . re p lace( te,   ne),   e [3  ]  =    (e[3 ]   || e[4]  | | e [ 5] ||  "" ) .rep l  a  ce (te,   n  e ), "~ ="  == =  e [ 2 ]   &  &  (e [3 ]  =   "  "  +  e [3] +  "  " ) , e. s  l  i ce(0 ,  4) } ,  CHIL  D : fun c tio n   (  e) { r  e t  u rn e[1] = e[1] .t o L o werCase(),  "n  t h"    = ==  e  [1].slice(0, 3 )  ? (e[3] || s e. er ror (e [0]),   e[4 ]  =  +(e [ 4 ]  ? e[5]  +  ( e[6 ]   || 1) : 2  * ( " even" === e [ 3 ]  ||  "o d d "  = ==  e [3])),    e  [ 5]  =    + ( e[ 7]  +    e[ 8 ] || "o d d"  = ==  e[3])) :  e [ 3] &&  se . e r ro r(e[0]),  e } , P  S E   U  DO:  f unction(e)   {   v  a  r  t  ,  n  = !e[ 6 ] &&   e[2]  ;   retu rn  G .CHILD . test(e [0   ] ) ?  nul l : (e[3 ] ?   e[ 2]     =  e [4] ||   e [5] || ""   :    n &&    X .t es t( n)    & &   ( t  = h( n,  !0 ))  && ( t   =   n. indexO f ( ")   " ,   n . le ng th -   t) -  n.l e ng  t h) &&  ( e [ 0 ]   =  e[0 ]. s  li ce ( 0, t),   e[2] = n .s l  ice (0, t)),   e.s l i   ce( 0,   3)) }  },   f il t er: { TA G :  funct ion (e  )  { va  r  t = e.repla c e(  te ,   ne). toLower Case() ; r eturn  "  * " === e  ? fu nc tion  (  )  {  r e tur n  !0   } : functi on(e) {   retur  n  e.no d  eNa m e    &&  e . nodeNa me .toLower  Ca s e  ()  = = = t } },    CL ASS:   f u nc tion(e)  {  v a  r t = m[e  +  "   "]; r et u r n t || (t =  n e w RegE xp (" (  ^|  "   +   M   +  ") "   +   e   + " ("   +  M   +  "| $ ) " ))     &&   m(e,  func tion  (e   )   { return   t.test( " s tring" ==     t y pe of   e  . c l   as s Nam e  &&    e . c las sName   | | "u n defi ne  d "  !=   typeof  e .g e t A  t t  rib u t e    &&  e . get A t t  r   i bu t e( "class") || "")  })     } ,   ATT R:     f u nction(n ,  r ,  i)  {   return fu nct io n(  e )    {   va r    t =   se. a tt r (  e,  n )  ;  re turn   nu ll  = =  t   ?  " ! ="   === r  : !r | |    (t    +=    " ", " ="  = =  =  r ?  t    === i   :   " !=  "   = == r   ? t ! = =  i  :      " ^ ="  =  = =  r  ?   i  &&  0    == = t.ind e xO f( i)  :   "* = " = =  =     r  ? i   &&    -1 < t  .i  nd ex O f (  i)     :  " $ ="  ===  r ? i  &&  t. s li  c e(-i.   len gth) == =   i : " ~ = "  === r   ?   -1  <  ( "   " +   t. re p l   a ce (B,   "  ")  + " ").index O  f( i )  :  "|   ="      ==   =  r    &&   ( t === i || t  . s   li c e(0 ,  i   .l e n g  t  h   +  1 )  =  = =  i   + "- ") )  }  },   C  HI L D:   fu ncti o n (  h  ,    e  ,   t   , g, v) {  va  r  y  =  " n  t h"    !==   h.slice ( 0,  3 )  ,    m   =   "last"   != =   h.  s  li c e(- 4) ,  x =  "of- ty p e "  = ==  e;  re t ur n 1 == =  g  & & 0  == =  v    ?     f u n c t i o n ( e )   {  r et u rn ! !e .p arentN o de } :  f u n  ct i  on(e, t, n) {     va r  r , i , o, a ,   s ,   u  ,      l  =  y  ! == m ? "ne x t S  ibling"   :  "  prev i ou sS i blin  g ", c = e.p a re n tNo de,  f    = x   && e. nod  eN am e  .to LowerCase (),  p = !  n  & &  !x, d = !1;   i f  (c)  {  if (y )   {  whi l  e  ( l) { a  =   e  ;  w hile (a  =    a[l])   if (x ? a.nod e  N  am e.toL o w e rCas e  ( )   ===  f  :   1     =  ==  a .node T y  pe )   r et urn ! 1 ;   u  =  l  = "o nly" = = =   h && !u && "ne xt Si b l ing "    } retu r n  !0 }   i f    (  u  =  [ m   ?    c.firstChild   :   c. l a   stCh ild], m && p)  {  d = (s = ( r  =  ( i = ( o  =   (a  =  c )[ S]  ||   (a[S] =  { }) )[a. u niqueI D]  ||  (o[a . u n i  q ueID] = {}) )[ h]   || []) [0  ]   =  = = k  &&  r [1] )  && r [2  ] , a =  s    &&    c . ch ildNodes [s ];  w hile   ( a =   ++ s & &  a  && a[ l ]   |  |   ( d = s  =   0  ) | | u.pop())    i f  (1  = = =  a   .nod eT ype  & &  ++d && a === e)  {  i[h] = [ k, s ,    d ];  b re a k }  } else if (p && (d  =  s  =   ( r =   (i  =  (o   =    (  a  =     e)[S]   | |  (a [S]   =  {})) [a. un  iqueID] ||  ( o[a.u n i q ueID]   = {})  )  [h]  ||  [ ]  )[0] = ==   k && r [1 ] )  ,  !1  ===  d) wh i le  (a  =    + +s  &&  a   & & a[ l]  ||  ( d    =  s  = 0)   | |  u . pop( )) if  ((x  ?  a. no deNam e. to L  owerCa   se(  ) = ==   f   :   1  = =  =  a.n o deType) & &   ++ d  &&     (p  && ((i  =    (o  =   a[  S  ]  || ( a [S]   =  {})  )[ a.  u  n iq ueID ]  | | (o[   a. un iq  ueID]  =    { }) )[h] =  [k,  d ]) , a = = = e))  br eak;  r  e turn (d  -=  v )   ==  =   g     ||  d    %  g  == 0   &   & 0 <  =    d   /  g } }   }  ,   PS EUD O:  f u   nc ti o  n(e,  o) {  var t,  a  =  b  . p s eudo s[   e ]  | |   b. s  e  t  Fil t  e  rs [e . t oLo w e r Ca se ()]  || se .e  rr   o r ( "  unsupp o r t e d  p se u d o:  "   +  e); retur n a[S  ] ?  a(o) :   1   <  a .len gth ? ( t  =   [e,   e,  "",   o ],   b  .s et F i l t  e rs.h  a s Ow nP rop e r t y ( e. to L o w e rC as e () )   ?  l e( fu nc t ion (e ,  t)   {    v  a r  n, r    =  a(e,   o) ,  i =    r   .lengt h;  while   (i --  )    e  [ n =  P( e,   r[i]) ]   = !(t[n]    =  r [ i]  ) }   )   :    f  un ct i  o n (e)    {    ret u  r n a(e, 0,    t) }  )  :  a  }   } ,  ps  e u  d os: { not:     le (  functio   n ( e)  {   va  r     r   =  [],  i  = [],    s  =   f( e  . r e pl ac   e(  $ ,  " $  1   ")) ;  r e tur n   s[ S] ?  l e(func t ion  (   e ,   t,   n ,  r)  { v a r   i, o = s (e , null,  r  ,  [] )  ,   a = e. le  ng  t h ;  while (a - -)   ( i  = o[a ] ) && ( e  [   a]  = !(t[a  ]    =  i  )  ) }) : f u  n c tion( e, t, n) { return   r [ 0]  = e, s(r, null,     n  ,     i   )  ,   r [  0] = null, !i. p  op() }  } ),   h  as  :   le ( f u n ction(t) { re t   u  r n  f un ct i on(e  )  {   re  turn    0     < se(t, e). le  n g  t  h } }  ) ,  co nt  a i n s:  le (f unc t ion(t) {  r e  t u rn   t   =   t .rep la c e (t e, ne),  f uncti o n(e )     {   re turn    - 1   < (e.text C ontent  || o ( e  )).inde xO f (t)  }  } ) ,  l an g  :   l e (f unc tion(n) {  r etu rn V.t e s t (n || "") || se.er r or( "u n supp o  r te d la n g : " + n),  n  =   n.repl ac e  (te,  n e).toLowe rC  a   s  e (  ), fun c  t  i on (e)   {  var  t ;   d o   {  if  (t  =   E ? e. la n  g  :    e . g etAt t ri b u te  ( "x   ml:lang")  ||  e .g et At  tr i  b  u  te ("lan g ") )  ret urn  (   t   =  t.to L owerCase())  =  =  =  n    ||  0    = == t.inde x   Of(n   +  "-")  }  whil e ((e = e.pare n  t No de) &&   1   === e.no deType );   r et  u rn  !1 }   } ),  t arget:  f unction(e )   {  v ar  t =  n .l  o c at io n  &  &   n. l ocati  on .h a sh; retu  r  n   t  & &  t.slic e ( 1)   = ==   e  . id },  r oo t:  funct i o n (  e)    { retur n  e = =  =  a }, fo c  u s :  fu nc  t  i on(e)   { re t urn e  ==  =  C.a  c tiveEle m  e nt &   &   (!C .h a s Focus  ||  C. ha s   Focus ( ) ) & &  !!(e . t ype ||  e .href  || ~e.tabIndex   )   },  en a  b l ed: ge(!1 ),  disab l e d: ge (! 0  ),  c hecked:  f u nct i o n ( e)  {    v a r   t = e.n od  eN a me . toLower Case( );   return  " i n put "    ===  t &&      !!e . c h ecked || "option"  == = t  &&   !!  e .sel e ct e   d   }, se le c t e d: funct ion (  e) {   re tu rn  e.p ar  e n tNode & &  e  . par e n tN o d e. se l ecte d I  nd   e x ,  !0   =  = =  e.  s  e le c  t e d } ,  e mpt  y :    f un c t  io   n( e ) {   fo   r    ( e   = e.fi rstCh il d;  e;   e  =  e .n ex t Si   b ling)if  (   e . nodeType   <   6 ) re tu r n  ! 1 ;   r e t  u rn !0 },   p a r   e nt: funct i o n(e) {  r etu rn   !  b. ps e udos.e   mp  t y ( e  )  } ,  hea   d e r :    fun c t  io n ( e )    {   r et u r n  J.tes t (e.nodeN ame  )   } ,    inp u  t :    f u  n  ction(e) { re tu r n   Q . test(e.no deN am e)  }  ,     b u t  to n :  fun  c   tio n (e ) {  va r  t  = e.n odeN a me .t oL ow e r C  as e  () ;  r eturn "i nput "  = = =   t &&  " b utto n"  ==   =   e .type | |   " butt o n"  = ==  t  }, tex t :   funct i  o n( e)    {  v a r    t;   r  et ur n  "i  nput "   =  ==  e. nodeN a me   . t  oL  ow  e rC a  se( )  & &     "t ext"  = = =  e.type   &&   (n ul l = =   (t  =  e  .g  e   tA ttrib ut e(" type ") )  | |   " te xt"   === t . toLow e r C ase( ) ) }, fi rs t : v  e (f un ct   i o n() { r e tu r n   [ 0] }) ,  l as t:  ve(function ( e ,  t) { r e tu rn   [t    -   1]   } ) ,   eq: v   e (function (e,  t ,   n) { re t  ur n   [n  < 0 ?  n  +  t  :   n] } ),  e  ve n : ve(f un  c t  io n( e ,   t) { for   (v  a r  n = 0 ;  n   <   t;  n  +=    2) e. push(n );   re tu rn     e  } ),  o dd:  ve(fu nc t i on (e ,  t  )   {  f o r (v ar n = 1; n   < t;  n  += 2 )e. pu s  h (n); retu  rn   e } ) ,  lt: ve( fu  n  ct ion(e, t, n)  {  for (va r  r  = n    <  0 ? n + t : t <  n  ? t  : n; 0 <= -  - r; )  e. pu sh (r );  r eturn e }  ) ,  gt :  ve ( fu nction(e ,     t , n) {  f or (var r =  n   < 0 ?   n  +   t  :  n ; + +r < t ;)e.pus h(  r ) ;  retu rn  e    })   }   }).p s  eu  do s .n th    =  b.pseudos.  e q ,   { rad io: ! 0  ,  ch e  c kbox: !0,  fi  le :  !0,  p assword: !0,  image:  !0 } ) b. p seu dos[e ]  = d e( e); for (e i n {  su bmit  :   ! 0, r e set: !0  })   b . p seu d os[e ]  = he( e)  ;  f u nction  me ( )  {   }    fu nctio  n    x e(e) {  f or  (va r  t   =   0,    n  =   e . le ngth ,  r  =   "" ; t < n; t ++)r + =  e[t   ] .v  alu e ; return   r }  func t i on be(s, e,   t) { v ar   u   = e. di r ,  l = e.n ex  t , c   =  l    | |   u,  f = t &&   "paren tN ode " = = = c,  p  =    r + +;  re tu r n e.first ?  fun ction( e,  t ,  n )  {  w h ile   ( e =   e  [u] ) if  ( 1 = ==   e .  n odeTy p e   | | f ) retu r  n   s(e ,   t , n); retu r n !  1 }    : functi on (e,  t, n) { var r,  i,  o ,   a  = [k, p];  i f  ( n) { whil e   (e    = e[u])  if    (  (1      ==  =  e .  n o d eT y pe  ||   f )  &&  s(e, t , n ) )  ret u rn  ! 0  }  el se   w h i l  e    (e  = e[u])  if ( 1  ===  e .nodeType    || f) if  ( i  = ( o  =   e[S ]  || (e[ S ]  = {}))[e. u n iq ueID] ||  ( o[e.uniq  ue ID ]    = {  }) , l && l ===  e .n od eN ame.t oLow er C as e(  )) e = e[ u ]  || e; else  {  i f  (  (r  =  i[c ])   & & r  [0] = ==  k  & &  r[1] === p)    retu rn a[2] = r [2] ;  i   f  ( ( i[c ] =  a) [2]   =  s(e, t,   n) )  re t ur n  !0 } return  ! 1   }  }  fu n c  tion   we(i) { re t  ur n  1    <  i .l e n gt h   ? func  ti on( e,  t  ,  n) {   v a r r   =   i  .  le n  g th; while  (r--) if  ( ! i[ r ]( e,  t, n ) )  retur n    !1;   r e t  ur   n  ! 0   }   :   i[ 0  ]   }  func t  ion Te(e,  t ,  n,  r,  i)  {   for  (var o, a =    [ ], s = 0 ,   u    =  e. l e n  g th, l =   null  !=  t ;   s  < u; s+ + )  (o =  e[s] )    &&  (n &&  !n( o , r,  i ) || (a.pus h(o ), l && t.p us h  ( s)));  re turn  a    } fun cti o n   C e( d  ,  h,  g , v  ,   y, e)   { r et ur n  v  & &    !v[S]  &  &  (v  = C e(v)),  y  &&  !y [S]  && (y =   Ce (y ,  e)) , l e(fun ction ( e, t,  n,  r ) { var  i,   o , a,  s = [] ,  u  =  [], l  =   t.  le n g th,  c = e || f u nct i on(e, t,  n)   { f o r  (va r r = 0 , i = t. le n g th;  r  < i; r++)se( e ,  t[r],  n) ;   r eturn  n  } ( h | |  "*", n. no deT yp  e ? [n] :  n , []), f = !d  ||  !e && h ? c :  T e(c,   s ,  d , n, r),  p = g ? y  | | (e ? d : l || v)  ?  []  : t  : f; if (g   && g  ( f, p, n, r ),  v )  {  i = Te(p,  u ), v ( i, [ ], n , r), o  =     i .leng   th; while  (  o- -)  ( a   =  i [o]) && ( p  [ u[ o ] ]  = ! (f[u[o]]  =  a )) } i f    (e)   { i f    ( y  || d) {  i f (y) {  i  = [], o  = p.length;   while  (o  -  -) (a   = p [o ])  &  &    i  . push(f[o]   =   a )   ;  y (null,   p =  [ ], i,   r)  }   o  =  p   . len g t  h; while  ( o -  -  )  ( a =  p [ o ]) &&     -1   <  (i =   y   ?   P(e  ,   a) : s[o ]   ) && ( e[ i]  = ! ( t[i ]  =  a) )   }   } e  l s e    p = Te(p == = t ?  p.splice( l, p.length )  : p), y  ?  y(nu l l ,  t ,  p,  r  )  : H.appl y( t , p)  })  }  functi o  n  Ee(e )   {      f or (var i ,  t  ,    n,  r  =    e. len g th ,   o = b.re l at iv e[ e[0 ].ty pe ],  a  = o  ||  b .relative[" "],    s   =    o    ?   1   :     0 , u  =    be(function(e) {   re t ur n     e   = ==  i  },    a,    !0  )  , l  = b e (function(e )   {  r e t u  rn -1 < P(i,  e) },  a,  !0 ), c  =   [ fu n ct i o n (e ,  t,    n  )    {  var  r    = !o  && (n  | | t ! ==  w )  | |  (( i  = t).nodeTy p e  ? u (e ,   t,  n)  : l( e , t, n ) ); return i = null , r }]; s <   r;     s+ +)if  ( t =  b.relative [  e [s].t ype]) c =   [ be(w e (   c)  , t)]; e ls e  { if (( t  = b .  f  il  t e r  [e[ s].type ] .ap pl y( nu l   l   , e [s].matches) )[ S]) { fo r (n = ++s;   n  < r; n++ )  i   f (b.relati  v e   [ e  [   n]. typ e] )  brea k ; return Ce  ( 1   <     s  &  &    we(c ), 1  <    s &&  x e(  e .s lice ( 0,    s   -    1).   co nca t({  va lue :  "  "  = ==    e[ s - 2].t y  pe ? " *"  :  ""   })).replac e ( $, "$   1" ),  t,  s   <  n  && Ee ( e. s li ce ( s,  n ) ), n     < r & & Ee(e = e. slic e( n)), n    <  r & &   x e( e)  )   } c.push(t) }      retu r n   we ( c)  } re tur n me.pr o totyp e  =  b .f ilters =   b  .   p seudos, b . s etF il t e rs  = n e   w me, h = se  . t  okenize =  f unction( e,  t) {  v ar   n , r,  i,   o   ,  a, s, u, l  =   x [e + " "];  if (l   )  ret ur n t  ?  0 : l .s  l   ic e( 0) ;  a  =  e, s  = [],  u  = b.preF i  lt er; w hile  ( a ) {   fo r   (o in  n  && !( r  =  _ .exec(a ) )  | | (r && ( a  =   a .s lic e ( r[0 ]  .lengt h)   || a),  s .push( i  =   [ ]) ) ,   n = !1, (r = z .exec (a)) && (n =   r.shi f t (), i . push ( { value: n, type:   r[0].replac e( $ ,   "   " )  }), a  = a .sl ic e (n . len gth)) ,  b  .filt er )  !(r = G[o].ex ec ( a)) | | u [ o ]  &&  ! ( r  =  u[o] (r ))  ||  (n = r. s h i ft(), i.pus   h({  value: n, t y pe:  o  ,  mat  c he s:  r     }), a = a . slice(n.leng t h)); if (!n) br e ak  } retu r n  t   ?   a.l eng th : a ? se.error (e) :   x(e , s ). sl   ic e(0) },    f = se.com p  il e  = fun c t io n ( e, t) { var   n  ,  v,   y , m, x,   r,   i  =  [],  o  =  [] ,  a  = A [e + "  "] ;   i f    (! a) { t    ||    ( t   = h(e ) ),    n  =  t . l  en gth; while   (n  --)   (a   =  Ee ( t[ n] ) )  [ S]   ? i.push( a )     :  o .push(a);    (a  = A (e, (v = o , m  = 0 < ( y =    i ).lengt h,   x = 0   < v .l ength, r = functio n (e, t,   n ,  r, i) { var o,     a,  s , u =  0, l = "0",   c = e &&   [ ],  f =  [] , p = w,   d = e | | x  & & b . find . TAG( "* ",  i ),    h  =  k +  =    n u l l  = =    p  ? 1    :   M ath.rando m()  || .  1  , g = d . len gt h; f or  ( i &&  (w   =   t   = = C   || t  ||  i );    l     !==  g  &&   null   !=  ( o  = d[l]);  l++ )   { if  ( x  & &  o )  { a =  0,  t   | |  o .o wnerDocu ment  = = C  | |   ( T( o ) ,  n = !E); wh i  l e      ( s = v[a++ ])  if  (  s(o,  t || C,  n ) )   {  r.push(  o   ) ;  brea k  }    i   & & (k  =  h )  } m & &  (( o  =  !s && o )  & &  u--, e & &  c. pus  h (o)) } if   (   u  +=  l,  m && l   !== u) { a  =  0;  w h ile (   s = y[a++])   s (c , f , t , n); i f  (e )  {  if  (0  <     u) while (l  -- ) c[l] || f  [ l ]  || (f [ l ] = q.cal   l (r));   f = T   e( f) } H.appl y   (r , f ),  i && !e   &&    0  < f.lengt h &&  1 < u +  y. le n  gt  h & &  se. uniqueS o rt( r ) } retur n     i && (k = h, w  =  p), c  } , m ? le(r )    : r )) ).sele ctor =  e  } re t ur n  a   }, g = se .  se l ect =  f u  nc ti o n(e,  t,  n,  r) {  v ar i, o,   a ,  s ,  u , l =  " function "  ==   t  y pe of e &&  e  , c  = !r && h(e  =    l. se lector  ||     e); if (n  =    n || [], 1 ===  c. leng th ) { if (2 < ( o   =  c[  0] = c[0] . sl ic e (0)). l ength  &&   "I D "  === (a =    o [0]).t yp e  &&  9 = = =  t . nodeTy pe   &&  E  && b. re lat ive[o[  1]   . t y pe ])  { if ( !(t =  ( b. fi n d.ID(a . m atch e s[0]. rep la ce(te,   n  e)   ,   t) ||  []  )[   0 ] )  )  return n;  l &&   (t = t.p   a  r e ntN ode) ,  e    =  e .slic e(  o .shift() .va l u e . leng t h) } i  =  G. ne  eds   Co ntex t.test( e)  ?  0  : o.len gt  h ;   whi l e  (i - -) {   i f  (a = o[ i] ,  b .rel a ti ve[s  =  a . t ype])   break   ;  if (( u  = b. find[s]) &&   (r  =  u (a. ma tches[0].rep l  a ce(te ,  ne),  e e .t e s t (  o[0]. t ype) && ye(t.parentN od e )  || t)))   {  if (o.s p  l ic e (i, 1) ,  !  ( e = r .l  e  n g th  && xe(o) ))    r  e t u rn  H .a ppl y ( n ,  r) ,  n; break  }   } } ret ur n (l | |  f (e, c) ) ( r,  t,     !E,   n ,   ! t  ||  ee . t  es  t( e )  &&   ye (t.pare n t N o de)  | |  t) ,     n   },    d.s o rt S table = S.sp  l it (  " "  ).s o r t(j).j o  i n( " ") ===    S , d. de te c  t  Duplicat  es  = !! l,  T () ,    d . s ort Detached  =  ce(fun ct io n  (e) {  retur n  1    &  e  . co mpa re D ocu me nt Po sit ion (C. cre at eE l e  m  e nt( " f  ie l  d s et " ) )  }),  ce (f u  n cti on ( e )  {  r et ur  n   e . inn  erHTML =   "  <  a h r e f  =' # '>< /a>" , "#"  = ==    e.firstCh i l  d .g etA tt ri b u te("hre  f " )  }  )  || fe("ty pe |h re f | h  e i gh t|wid t h ",    f  u nction( e ,   t  ,  n)  {     if  ( !n  )  r e t ur n  e.   g e  t A t tr ib ut e(t,  "ty  p  e " = ==   t .t oL ow er Ca se ( ) ? 1  :    2  )  }), d.attr i bu te s && ce (f u nct ion(e)  { retur n e   .i n ner H  T ML  = "<i np  u t/>", e  . f irstChild . s et A t tribut e( " va lu e ",  ""  ), " "  ===    e. fi rs tC hi ld.ge  t A t  tr ib ute(" v alu  e "  ) }) ||   f e ( " value  " ,  f u ncti on( e ,   t, n) {  if  (!n && "in pu t   " ===  e.no d  eN a  m  e. t  oL o w erCase() )  retu  rn e. def au l tVa l ue    }) , c e( f  unct io n(e)  { return n u   ll == e. g et  A  tt r ibu te("di sa  b l e  d") }) | |   f e( R ,  fun ct ion (e ,  t,   n)  {   v a r    r; i  f   (! n)  r etu r n   !0  = == e[t ]  ? t.to L   o  w e rCa s  e  ( )  :  (r =  e   .getAttri b u te No de (t ) ) & & r .s pe c if i e   d  ?  r.va lu e    : null  }  ) ,     se   }( C   ) ;  S . f i   n d =  d,  S. expr  =   d.selector  s ,   S. ex   pr[ ": "]  = S.e x  p r.pse udo s ,   S . uniqueSo rt  =   S. u ni q u e  =  d.uniqu e  Sort, S.t   e xt  = d.ge tT ex  t ,    S. i sX  MLDo c  = d.i  s XML, S.co n  tains = d.c on t ains,   S . e scapeSelect  or =  d .escap  e ;  var h =   f un c ti on(  e ,  t, n) {  va r r = [],  i = void  0  ! == n; wh i  le   (( e  =  e[t ])  & &   9  !== e.no deT ype) i f (1 === e. no   deTyp e )  { if ( i && S(e  ) .i s(n))  b re a k  ;   r.pus  h(e)  } return r }, T   =   func tion(e, t)  {  f or (va r n   =  [ ] ;   e; e = e.ne xtSibl i ng) 1   === e .nodeTy pe  &&  e !== t &  . s   ( )      ;   re   t  ur  n  n  },k  =S. e x p r .a  tc h.needs C o nte xt ;  fu n c t i  on A(e , t)   { ret u rn e.nod eN ame &&    e.nodeName . to Lo we rC ase() === t .toLowerCas e () } var N  = / ^<  ([ a-z][ ^ \ /\ 0>:\x20\  t \r\n\f]* )[ \ x20\t\ r \  n \   f] *\/?> (?:< \ / \1>|  )   $/i;  f unct i o n j( e, n,   r)  {  return m(n) ? S. gr e  p (e, func  t ion(e, t )   {    r   e turn   ! ! n . ca ll(e  ,  t,  e) ! =  =  r }) : n.n o d eTyp e  ? S. g  r  ep (e,  f uncti on( e) { return    e  === n  !== r  } ) :   "st ring"  ! = typeof n ? S.grep(e, function(e) { return - 1    <  i.cal l (n, e) !== r  }  )    :   S .filter(n,   e ,  r   )   } S . filter  = fun ct  ion(e ,  t ,  n) { v ar  r   =  t[ 0  ] ;  retur n  n && ( e  =  ": n ot(" + e + ")") ,   1    = = =  t .len g  t  h  && 1 ===  r  .  no d eType ?   S . find .m at ches S ele c to r(r ,   e)  ?  [r]  : [ ] :  S. fin d.matc hes(e, S .gr ep(t,  f unction(e)  {  r eturn  1 ===  e.n o  d   e  T yp e })) },  S .  fn .ex ten d( { find:  fu  nc t io n(e) {   v  ar t, n  , r  =    t  his.lengt h, i    =   t   his ;  if     ( " s   t r i n g" !=    typeof e ) re  t u  rn  th is . p us hS tac k(S (  e)  .f   i lter ( f u nc tion (  )  {  fo r  ( t    =    0; t  <     r ; t++  )i  f  (S.contains (i [t],   t h  i  s)  )    r e t u rn !0  })) ;     fo r    (n   =     th is   . p u  s hSt a c k( [] ),  t =  0; t  < r ;  t++ )S . f ind (e ,  i [ t] ,  n ) ; r e t  u rn 1  <   r  ?  S . u   ni  q   u  e  So rt (n)     :    n    }   ,  fi l te r :   fu nc   ti on (e )  {  r e tur  n   t  h is   .  p  ush   S tack ( j( this, e   ||  [], !1   ))   },  n ot:  f u nc t i o n(e ) { return thi s. p ush St ack( j( th is ,  e  ||      [  ] ,  ! 0 ) ) }, is:  f u nc tion(e )  {  r eturn  ! !j ( this,  "s trin g   "    ==   typ e of  e &&   k. test( e) ? S(e)  :   e  | |  [  ]  ,  !1) .length  }  });  va  r   D, q   =   /^(  ? :\s*( <[ \w\W  ] +  > ) [ ^ > ]*| #([ \ w -] + ))$ / ; (S.fn.ini   t   =   funct io n (e,  t  ,      n )  {   var  r, i; if (!e) r eturn thi s ;   i f  ( n =   n ||   D ,  "str ing" ==   typeof    e)   { i f  ( !( r  = "<"    = = =    e [0 ]    &&  ">"   == = e[e   .le n g th - 1]  && 3  <= e .leng th  ?    [n u l l,  e, nul  l]  : q .e xec(e)) | | !r[1]     && t)  retu r n   !t || t.jqu e  ry ?  (t || n ) . f i n d(e) :    thi s.  cons tructor (t ) . fi nd(e);   i f  (r[1 ]  ) { if (t   =  t  in stanceof  S    ?  t[0 ]   :  t,  S. m e r  ge(th is,  S .parse H TML(r [ 1],   t && t.n o deTy p e  ?    t  .ownerDoc u m  e n t | | t : E , ! 0) )  ,   N.test(r[1])  & &   S. i sPlainO b ject(t)) for (r in   t)  m   ( this[ r])  ?   t his[r](t[r]) : t h  i s .attr(r, t[r]);   re tur n  this } return (i  =   E. ge tE le m  en   tById (r[2])) && (this[0] =  i, this. leng th  = 1),  th i s } retur n  e.node Ty p e ? (this[0  ] = e, this.leng th =   1, t h is) : m (e) ?  vo id 0 != = n. r eady ? n.read y (e)  : e( S ) : S.makeArray(e, th is) }).proto t ype = S.fn, D = S(E); v a r L = /^(?:paren t s|prev ( ?:Until|All )) / , H = { c hi ldr en: !0, con  t e n ts : !0, next: ! 0 ,  pre v : !0 }; functio n O(e,   t ) { wh ile  ((e = e [  t]) && 1 !  == e .no d eT yp e); return e  } S . fn.extend({   ha s:  fun ction(e) { var  t   = S(e,  t hi s), n     = t .length; r eturn this .f i lter(function() { fo r (var e  = 0 ; e  <  n;   e++ )if (S.c on t ains(t his, t[e ] ))  ret urn  ! 0 })   }, closest :  function ( e ,  t) { var n, r = 0,  i  = th i s.length,   o   = [], a = "string"  !=   t yp eo f e && S(e );  if  (!  k .t  est(e) ) f o  r    ( ; r  <    i; r++)for    ( n     = t h i s[r];  n  & & n   ! ==   t;   n  =  n. pa r e nt Node ) if  (n.  n od e T ype  <  11  && ( a  ?  -1 < a.index(n   ) :  1   = = = n.no d eType   &&  S .fi nd.mat c hes Sel e ctor( n , e))  )  { o.p us h( n);  brea k  } ret ur   n t his.pushStack(1 < o.leng t h ?  S.uniqueSort(o ) :    o ) }, index:  function(e) {  re tu rn  e   ? "  str in g"  = =  ty pe o f  e ? i.call( S(e) , thi s [ 0 ] ) :   i .c a   ll (t hi  s ,    e .j q  ue r y  ?   e   [ 0  ]  :  e) :  t  h i s[0 ]   &&  t hi s[0].pa re n  tN o de   ?  thi s.fi r st( ) .   p r ev  Al l( ).len gth  :  -1  }, add : func t   ion ( e,  t  )   {   retu rn  t h is.p u s h   St a  ck (S.uniqu eSo  r t (S.me  r  ge  (  th i s .get(), S( e  ,  t )   ) ))  }, ad dBack :   func ti on(e  ) {  re t u r n  t his.a dd ( nul l  = =   e  ? this.pr e v  O b ject :  this. prevObje c t . f  i lter(e))  }     }   ) ,  S.ea  ch   ( {  p  a  r  en t:   fun c t ion( e)  {  v ar  t = e. parent  No   d e; r e t urn t && 11 !==  t . nodeType ?   t    : nu ll   } ,  p arent s:    functi on(e) { ret ur  n   h (e ,   "pare n tNode "  )  }, pa r  ent sUntil: fu nc t i on (e, t, n)    {  ret ur n  h(e,  "p are n tNode" ,    n ) }, next: f  u   nction(e )    { retur n    O( e ,   "n extSibling" )     }, pr e v :   fun ct ion ( e)  {   r   eturn O(e, "pr ev  i ou sS ib l  in g"  )    },  nex t A  ll: funct i o n  (e)  { return  h ( e ,    "n ex t S ib li n g ") }, pr ev Al l:  f un ct ion(e  )   { ret u r  n  h(e,  " p re vi o u  s S ib l  i   n g   ") } ,  n extU nt i l  :  fu n c ti on( e ,    t,   n)   {  retur  n    h (e ,   "n e x  tS iblin g" ,   n)   } , p  r ev U ntil : f uncti on( e, t , n   )   {   re  t u rn h(e ,  " p re viousSiblin g"  ,  n) }, sibl in gs:   f  unctio n (e) {   r  eturn  T ((e.pare nt  Node || {}).firs t Chil d,  e) },  c hi ld re n:  f   un ct i on(e)  {  re t u r  n T ( e.  f  ir  stChild)  } ,  co n ten ts : f unc  tio n (  e) { retur n   n u  ll   ! = e.cont en  tD o  cu m ent  &&   r  (  e .c on   te ntDoc umen t) ? e. co n tentDo  c  u ment : (A(e,  "t e mp late")  &&  (e    =  e. co n te nt  ||   e ) ,   S .merge([ ],  e. c h i l dNo des ))   }  }  ,  fu n  c tio n (r,    i)  {   S .fn[ r]  =  fu nct i o n  (e ,  t  )  { v ar n = S.map(t h is, i,  e);   r e turn "Until" !==  r .  sl ice( - 5) &&  ( t =  e) , t && "s t  ri n g"  =  = typeof t && (n = S.fi l te r (t, n)) , 1 < this.  l ength    && (H [r]  || S.un iqueSort(n),  L.t e  s t ( r ) && n .re verse())  ,    t his.p u shSt ac  k  (  n) } }   )  ;  var  P  = /[ ^\x20\t\r\n \f ]+ /g ;  f u n c  ti on  R (e )   {  r et ur n  e   }  f un c  t ion M  ( e )  { th ro w    e    }  f u nct  i o n I(e, t,  n   ,   r ) { var   i; try { e &  & m (i = e .p romise)   ?  i.call( e  ) . done(t  ).  f   ail(n) :   e && m(i =   e.t h e  n  )  ? i. cal  l (  e  ,  t,   n ) : t .ap p   ly (vo id 0 , [ e  ]  .sli c e  ( r) )  }  c a tc h   ( e) { n .  a pply(void 0,  [ e] )   } }  S.C a   l lbac ks  =    f   un  c  tion(r )  {  v ar  e, n; r   =  "s tring "     = =  t ypeo f r ? (e  =   r , n   =  {},  S. each(e. ma tch(P) || [ ]  ,    f unct ion(e, t) {   n  [t  ]    =   !0 }), n) : S. e  xt en d( { },  r ) ;  var  i, t, o, a ,    s   =   [], u =  [ ] ,   l  = -1 , c  =  funct  i o n( )   {  for ( a = a | | r .o nc  e ,  o = i = !0 ;    u.length;  l  =  -1) { t =  u. s h if t(); wh ile (+ +l <    s.l en g th) !  1   =   == s [ l ]. ap p l y(t[0 ] ,   t [ 1  ])    &&  r.stopOnF al se  & &  (  l  =  s . le ngth, t  =  !1 )  }  r .memory |  |  ( t  =  !1 ), i  =  !1, a  &&   (s = t ? []  :  "")   } ,  f =  {  ad d: fu   n ctio n()  {  r etu rn   s & &  (t   && !i && ( l = s.len gt h  -    1,   u. push(t) ) , fu nc t io n  n(  e )  { S.e  a ch (e ,  fu nc ti on  ( e,      t) { m(t )   ?  r.u niqu e  &&    f  . has(t)  |  |   s .p u sh (t ) : t && t .  l ength && " st  ri n  g" ! ==    w ( t )  & & n(t )  }) } (  ar gu m e   nts),    t & &  !i && c()), t h is     }  ,  remove:  fu n  c  t i o n ()    {  r  et u rn S .ea   c h ( argum en  t s,  fu n c tion (e , t) {   var n; whil   e  (- 1  <  (n =  S. i  n  Array(t, s ,   n ) ))  s.spl  ice  (n ,  1 ) , n < =   l   &&  l-- }) ,   th i s  }, has : f unctio n( e )  {   return e ? -1  <    S .  i  nA r ray(e, s )   : 0  <   s .l ength },  e  mp  t y: fun ct  io n () { ret  u  rn  s  && ( s  =  []),  t  h  is }, di sab l e :  f u  n c tion()  {  return  a    =    u =  [], s  =  t = "",  t his },    di sabled: f u nc t i  on () { re t urn !s },  l  oc k :    f un c tion () {  r etur n   a =   u  =    [  ], t || i   | | (s  =  t =   " ") , this }, lock e d :   function ()  { r e t u  rn    !! a  },  f ir   e With :  f uncti on( e ,  t)  {   return a || (t  =   [e , (t = t  || [] ).s li ce ?  t.slice()   : t], u.pu sh  (t   ) ,  i | |  c( ) ),  this  } , f ire :  f  u nc t i on ( )  {  return f.fi r e W ith( t  h i s , argu me nts),  this }, fi r ed:   f un ction() {  r  e t u  rn !!o  } }; return f } , S . e x tend({ Deferred: fu n ction (e ) {     va  r  o  =  [ [" not  if  y" ,  "p rogress", S.C al l bac ks("memory"   ),   S. C a l  l ba  cks ( "m emory"),  2 ] ,  ["res ol ve " ,  " d one",  S.Ca ll backs("once  me  m  o  r y"), S.Ca ll backs (" o nce me mor y " ), 0  ,   "resolved"] ,  [ "reje  c  t", "  f ail" , S .C a llb ac ks( "once memory"), S. C  all back s ("  o nc e memory"),  1,  " rej  e c  ted "]], i =  " pe  n d in g" , a = {  sta te: func t ion() { re t urn i }, always:   fu nc tion() { re tu rn  s .don e(a rgum ent s ). fail( a r guments), t hi s  },  " c  at ch "  :   f u n   ction(e)  { retu r n  a .t h e n( nu l  l ,  e )    } , pipe: f unc  t i o n( )    {   var i  = a rg u  m  e nts ;   retur n  S.  De  ferred (f unc tion( r) {    S .each( o,   f unc ti on ( e ,  t )  {    v  ar  n   = m   (  i  [   t[   4 ]] )  && i[ t [4] ] ;    s   [t[1]](func t  i  on( )  { var   e =  n  && n.a   pp   ly(t h is, argument s );  e &&  m(e.p r omi se) ? e.p r o mi s e( ).p r ogre ss(r.not if y).done( r.res ol ve).fail( r .r e jec t)     : r[t [ 0 ] + "Wit h" ](this,  n  ?   [  e ] : ar guments)   })  }  ) ,   i =  nul l }).pr o  m ise() },  then: f un c tion(t, n, r) { v a  r   u  = 0; f unc t i on l(i, o , a , s)  { r e turn funct i on  ()  {  v a r  n = t his ,  r  = arguments, e  =    f u n ction( )  {  v a r e, t; if (!(i  < u)) { if ((e = a .a pp ly (n , r) ) === o.p r o m ise()) throw ne w T ypeEr r  o  r("Thenabl e   s e lf-res ol uti o n") ;   t    =  e  & &  ( "o bj ect"  = =  ty pe o  f e || "functio n"     = = t yp eof e)   & &  e.the n ,  m( t ) ? s  ?   t .c all(e,   l(u,   o ,  R,   s ) , l(  u ,    o  ,  M ,   s ) ) : (u++,  t  . call(e,  l (u,   o ,  R,  s ), l(  u , o,  M, s ),  l (u ,  o,   R,   o .n o t i f   y Wi  t h) ) )  : (a !== R && ( n    =   voi d  0 ,    r = [e ]) ,  (s   || o.re so lv eWi th )( n,  r) )  }    },   t   = s ? e  : funct ion( )  {  tr  y  {  e()    }    c at ch     ( e )  {  S.D e f  e r re  d.  e xc ep tionH ook  & & S.D ef e r  red .e x ce   p ti o  nH  o ok( e  ,   t .sta ck T r a  ce ) , u   <=  i   +  1  &&  ( a !==  M    &   &   (n   =   vo  i d   0, r =  [  e]   ),   o. re je ct Wi t  h  (n,  r ) )  } };   i  ?    t( )   : ( S .D e fe rre d. g e  t St ackHook   &&  (t.s t ac kT r a ce = S . Def e rre d .g etStac k  Ho o k() ), C.se t T  i m eo ut ( t  ))   }   }  r e tu r n  S.Defe r r e d (f unctio n  (e ) { o[ 0][  3] .a d d(l(0, e,  m (r ) ?    r  : R, e  . no   t i f yWith ) ) ,  o[1][ 3 ]. a dd( l(0 ,  e, m( t) ?    t  : R)), o[2][3].   a dd(l( 0 ,  e,  m(n) ? n :  M ))  } ).pro mi s e()  } ,  p r o m  i  se: fun c t io  n  (e) { re t ur n  n ull   ! = e ?  S.e xt en d (e, a)     :   a   } }, s  =  {}; return  S.each(o, func t io n(  e ,  t) { va r n   =  t[2],  r =  t[5]; a[ t[1]] = n.add,  r & & n  .ad d (f un c tion()  {   i = r   }, o[ 3  - e][ 2]. d  is  able,   o[3  - e  ][3].dis able,  o[0] [2]. l  ock  ,   o [0 ] [ 3] .lock ),  n. add( t[ 3].fire) ,  s[ t [0 ]] =   functi on( )  { r e turn s[t[0]  +   "Wit h"](this =  = = s ? v o id 0  :   thi s,  argu ment s), th i s }, s[t[0] + "  W i t h "]  =  n.fireWith  }  ) , a.p romise(s) ,   e  && e.c a l l (s, s), s }  ,  when: f u nc t  i on(e) { var n = arg  u ments.le n gth, t = n, r  =  Ar r ay( t ),  i =  s . cal l(a rg um ent s) ,  o = S.Deferred() , a = f un c tion(t) {   re turn fun ction(e ) {  r[ t]    =  this, i[t]  = 1  < arguments.le ngt h ?  s .  ca ll(argu men ts) : e, -- n | | o.reso lve With(r , i ) } };  if  (n <= 1   &&    (I (e,  o.done (a( t)).r eso lve, o.re jec t, ! n),  "pe ndi ng"  == = o .st ate() ||  m( i[t] &&  i [ t].then) ))   return  o.t hen(); w hil e  (t-- )  I(i [t], a(t), o .r  eject);  ret u r n o. pro mise() } }); v ar  W = /^(Eva l|I nternal| Ran g e|Re fe re nce| S yntax|Type |URI)Err or$/;  S .Deferre d.exc ept i onHo ok  = function (e ,  t) { C.console &&   C .c ons ole.warn   &  & e && W.test( e. name  )  & & C.c o  nsole.warn ( "jQu ery.De f e  rr ed  e  xce ptio n: " +  e. m essage ,   e .st ack , t)  } ,  S. readyExc ep tion = f unction(e) {  C. set Tim  eout(funct ion() {  thro w e }) }; var  F  =  S.D efe rred(); func ti on B () { E .r e moveEventListene r ( " DOMCon ten tL o  ade d" ,  B) , C.rem ove Ev e nt L ist en e r ("lo a d", B), S . r  ea dy() } S .fn.read y  =  fun ctio n(  e ) { return F. the n( e)["ca  t c h"]( f un c t ion(e)  {  S.readyExc eption(e) } ), t h   is  } ,   S.e xtend({ isR e a d y:  ! 1,  r ea dy W  a it :  1 ,  r ea dy  :    f  un ctio n(e) {  ( !  0     = = = e ? --S.re ad  y  W ai  t  :  S . i  sR e a dy)  ||  ( S  . i s R  ea dy  =  !0) !==  e && 0  <  --S. re ad  yWait ||   F. resolveWi th(E,   [S]) } } ) , S.read y .then   = F.t h en ,  "c o mpl e te" = = = E .read y  State  ||  "load in g"  !==  E. rea d ySt at e &&   !E .  do cumentEl ement.doScr ol l ? C. se tTimeout ( S.rea  dy ) :    (  E.addEven tL i stener (" DO M Co n   te nt Lo  a d e   d" ,    B),  C. ad dE ve nt Li s  t  ener("load", B)); v ar  $  =  f   u n  cti o   n (e ,   t, n, r,  i ,   o  ,  a) {  va r  s =  0,   u =  e .l eng th ,  l  = n ull = = n; if (" object" == =  w( n  ))  for (s  i n  i  = !0, n )    $ ( e,    t, s , n [s], !0, o ,   a ); else if (v oid   0    !== r && (i  =  !0,  m( r)   | | (a = !0), l  &  &   (a ?  (t   .call (e,  r),  t = null)  :  (l    =   t , t = f u n ction(e ,  t,  n  )   {  ret ur n l  .call  (  S (e), n) }) ),    t)) f o r ( ; s < u; s+ + )t (e [ s], n, a ? r : r.c a l l(e[s ] ,  s ,  t ( e[s],  n) )) ;  re tu rn  i  ?  e : l  ? t. c al l(e) :   u ?     t  ( e [0],  n)   : o  },   _  =  /^ -m s -/ , z = /-([ a-z ]  )/  g;  f u nc t i o n U(e,  t)      {  retu r n  t.toUpp er Case() }  f unction X(  e  )    { retu rn     e  . re place  (_  ,  "ms-" ) . r e place(z, U)  }    va  r     V  = fu nct i  on (e )  {   r   e tu r n   1  ===  e . n o de T y pe ||   9  = ==  e .n od e T y pe    || !+ e  .n o deT yp e }; fun c ti on  G ()   { t his.expando  =   S.expand   o +   G .uid++ }      G.u i   d = 1, G.pro to type = {    cache  :  f  u  n  ct i  on  ( e )  {  va r  t  =   e[this.expa ndo  ] ;  r et ur n  t    ||  (t  =  { }, V(e) &  &    ( e.n o de Ty  p  e  ?    e[ t h is.expan  do ] = t :   Ob je c t  . d  e f i n   eP r ope r t  y(   e, th is . e x p an d o,   {  value : t ,   c onfig ur  a bl e: ! 0    } )  ) ) ,   t      } ,   set:   fu n ctio n( e ,   t, n) {  v a r    r ,   i  =  t  h i s . c a c he(e);   i  f   (  "s t r in g  "  == typeo f    t)  i[ X ( t) ]   =  n; e  ls e  for ( r i n  t) i [X ( r)]   =  t[ r ] ;   r e turn  i  }, g e t:  fu nction(e, t)  { r e turn v oid  0  == = t ?  this.c a che(e)   :    e [this . expando] &&  e[this .exp an do] [  X (t)]  } , access: f un  c t  i o n ( e,    t ,   n ) { return   v   oi   d     0   == =  t  ||  t   &&   " s tri ng" == ty  pe  o f t && voi d 0   === n ?  thi s. ge t( e ,   t)  :  (t h  i s.set(e,  t,  n) ,  vo i d 0 !== n ?   n  : t)  } ,   re mov e: func tion(e , t) { var  n ,  r  =  e[ this.e xpand o] ;  if  ( v oid 0  != =  r)    {  if   ( v oi d  0 !== t)   {  n = ( t   = Array.is Ar ray  (  t  )  ? t.m ap(  X)  :  (t  =  X (t)  )   i n r ? [t] :   t.  m a  t c h ( P )  | |  [ ] ) .l eng t h ;     wh  i le    (n - - )  dele te r[t[ n]] } ( voi d  0  === t | | S.isEmptyObjec t( r ) )  && (e.n  o  deType ?   e[th is . e xpando]  =    vo  i d 0 :   del e te  e[this.expando ] ) } }, h asData:  f unc ti on( e)   {   v ar  t =   e [ t hi  s.e x p a nd o ] ; return  v o id  0 !== t  &  & ! S  .isEmp tyO  bj ect(t)   }    }  ; va r Y = new  G,  Q   =   new  G ,    J   = /^(? :\{  [ \w \ W]*\}|\[ [\w \W ]* \ ]  )$  / , K  =   / [   A- Z] /g ;  fu n c   ti  on  Z  (  e  ,  t, n)  {  v  ar r,    i  ;  i f (voi d  0   =  = =   n && 1  == =  e . nodeType ) if     (r  = "data-" +  t . replace(K,  "-$  &" ).to Lo we rCase ( ), " s tring  "   = = typeof    (n  =   e.get A tt r ib u t e(r ))) { try { n   =  "  true" ===   (  i  =  n) || "  f  als e"  !== i    && ("n ul l " === i  ?  nul l  :  i  =  == +i + ""  ?  +i :  J. test (i )  ? JSO N .parse(i) : i ) }   c  atch (e) {     } Q.se t(e ,   t,   n)  }   e l se  n = vo id  0;  r et urn  n  } S.e xte nd   ( {    h as D ata :  function (e ) { r e t  u  r  n Q.h  a s Data(e) || Y.ha sD ata(e )   } ,  d a t a: function(e,  t ,  n)  {    re t urn   Q .ac cess(e ,  t,  n)  } , r  em ov e D at a:   fun ction(e, t )   {  Q . r e move(e, t ) },  _ d  at a: func  ti on(e,   t  , n) { r et ur n Y .acces s (e, t, n)    }  ,  _r emoveData :   f  un cti on(e, t) { Y. re m ove (e, t) } } ),  S .fn.e x  tend({  dat a :  fun ct i on( n,  e ) {   v a r   t  , r, i , o = this [  0 ],  a = o  & &  o .at t ributes; if   (v oi d  0  ==  =  n) { if (this.le ng th && (i =  Q.get (o ),   1 ==  = o.n od  e Type && !Y.ge t (o , "hasD ataAttr s"  ) )) { t = a.len  g  th; while   ( t--) a[t] && 0 == = (r = a[t ]. na  m  e) .index Of ("data- " ) & & (r =      X( r .  sl  i c e(5)) , Z (o, r , i  [r ]) );   Y  . set(o,  " ha sD  at a A tt rs ",  !   0)    }  return  i  }  re  turn "obj e c  t "  = =   t  ype of   n  ?    t  h i  s .   e   ac  h( function() {  Q   .set(this, n)  }) :   $ (t h  is  ,  f  u n ct i o n (e) { var t ;   if (o & &     void    0  ===  e ) r e t ur n   void 0 ! ==     ( t  =  Q.g e t( o , n )) ?  t  :  v o i d    = = (          ? t :  vo id  t h i  s.e a c h(fu nc  t ion( ) {etts e) })  }, nu ,     a   n s   en  th,     ! )      v       io n    e u    t  . eac h  c  t o  ) { Q.eo (t    )  }    }  )  S en({  quu :  f uc o    t,  n) {va   if  (e) r urn  =  (  ||" x") +"q ee   r   . t(  t),  n  &  ( r | | Array   A   ra(  ?r      c ce s (e ,  t, . keA  rra  ):  .   )), r || [ ]  } d ueue :    n(e    )  = t   "  fx"; v  n  = S.qu u  ,  t , r .leng h , i = n.   i f t (),  =  . _ q u euo  s(e,  )   ;    " in p ro g  s   = ==  i   & &    =  n. s if  t( )   r -),  i & "  "== t & & n. n s t inprge   s  " ,  ee  . sop, i   a l  ,func o(  {S.d  u  e, t    ,   o)) r &  oempty .fi   )   _qu e u    o o  u tio , )   va r  n  t   u eHo o ks ";     nY.ge  (   n )     e, n    e pty: .C l c   c e m e m  o ry    fun ct on { Y.re        + e e ", n]    })  ) }) ,     .exten  { qu e  u      cti ( ,       {  v     ;r     n ting"  !=    yp eo t&  = t,  = x", e-    ar gumn    ng         ? S. e e   h []  :i 0  =n  h  :  this. ac fu n t on()     v e    =  qu eue       , t  ; S  u Hoo   (   s  , t  " = =   & " ness" !==     [ & & Sq ( t h i ,   }) }, q ue : u  ne      er t    cf c   n ) { .d uet   ) }} cleaQueue: fti on(e) {  etu h  qu (e |  "f x ,  [ ]  ,  pr mse: unto  ,   v r  ,   = ,      e e   o = is   a hi.l n th    = f c t ion({-   | .eso lv eW ( [o])  ; s trin g    typ        & (t   e      vo id  )     =  e  |  "    h   ( a- )     =   .g et(o[a],   +  qu eu eHook    ) &n  m pt y   &  r++ , e t y.add(   ; retr n  ()  , i.p  iet  } );  ar e= /[+- ] ? d*   \.  ( :  ] [  +- ]\ |)/ our ce,   t e   new R e g Exp("^( ?   [ ])|) ("   ee + " [a-   z%)$" " i")  , n = ["T p" "Right" , " Bo o m",  Lft  r = E cumentElemen t ,  i e = tio n(e    rern S.   on tain (e. o wne r cume   t ,  e) }, o   =  { mpse:!0  } re.gt R ootNode &&  (  i e = funct o  n( ) {r e t  Sc t  i  n e.owne cme   e) |  e tRoo tNod e (o ) = = =  wn rDocument   ; var a    =   f tion(  t )    turn "n  o ne " =    ( e  = t  || e  .      y  le .d ispl ay| "" == =    e.tye.disply &&  i    () & none" == = S. ss(   "d sp a  ;  f un ction  s  , t    r) { va r i,  o ,  =   20   = r ? f ction {  r  u   r .c r()  }  :   c   () { ret u r  S.    s( , t, ""   }, u  s( ) , l =  n&& n [3 ]|| ( cssNu r[]   "  " : "px ")  c  =  o  eT e  S.css Nu  m  er   || "x !== l &    + u) & &te.eec(  ss(e,  ) f ( c c [3] =   l ) { u = 2,  l  =    c 3],   c     | |  1;   w hi  le  a--)S.st y le(e,t,    l) ,  (  -      *  -    = s )/ u | . 5)) <= 0 &&  a = ) c =   o ; c *   2, S. t y      c  + l), n =   n |  [] }   eturn      (c    ||   + ||   0, i =   n[1]? c   [1 ]  + 1)     [2]  +n[ 2 ,r && (r   n   t   =  l , r.sat = c, red = i ) i }  var ue  {};  u  o n l e( e ,  t {f  (vr n,  ,   , o,  a,     u, l    [   ,  f  elen   h      ; c+)(r =  e[  c] .  y le   & (n =  r . s tyle. ispl a y,       n one"    =     n   &   ( l  ]  =  Y .   et (r,  "   d s pla  y") | ul , l[   || r . s ty   dis a  "  ) , "  " === .s  yle.  sp   ay & & ae(r) & (  l [c   =       vo  d , a =       r).ow er    oc  u   t s = i o  eNam     (u =    s])    |  |   ( = a .bo a  p pendCh i  (  .r teEl m       s) ),  u  .css ( o, "d   p lay),  o.  r  entNoe re e C  hild( ), "      u&&  u  =   "b lo k  ")   ue[]   )))   ne = n   &&  (l[ =       str ,   "d i  p  y"  n) ))  ;  f  (  = 0   c < f;   ++)n   l l ! l[c] && c st y   .  d  is   = l [  ; t u r n e } S.fn ext  d (   sow: f un  i n    r trn  l e(th   !0) i  : fn tion() { tu  le  is     , t   o     f ction  { r e  rn  " oolea ==  tp f  ?e ?   s     :t his. h  e )  thi s e h u    () {  e(t )? ( this) . ow : S  is  hi  de (     } })     c  , e,  p / ?:ch  kbox|r  d  / i,   e  <([ a- z [ ^ \/ \>\x 20 \  tr\ f  ]    /   he=  ^ $ mdule $|  \  j  a  ) r t  / i;   e =  rea ocu  nt  n ( )  .a p end C i d(E.   ea eE  eme  (  "div"   (     . c e at e    p ut" ) )set  r   ue(    t   e, a i o  "), fe. et A riu e " c ec " ,  e ke  ),  fe  e  t tri   ("a  "  "t"  e  p en Cildfe ),  c cC l n   ce.c ln  d ( ).con eNo d e(0las t C ild. c k d, ce. n er H TM       >  x   e>"   y.   o e h ed   !! c  c   No ( !0  ) .  atCh l .ea l a l  e, c e.  ne H TM   =  " t n  /p  o ", . on  =  !! e.   tC h  l    r       he     [ 1,  "  tae>"   "/ a >"   , c o   <tb l  e  >< c grou p>    /colg r  ><t b l >  t :  ,       e>< o y" ,  " < ody> </t  e ]  td  [ 3, " t    ><t bo d    < r>" "  tr>        od y>< l     d e   l  [   " "   ] ; un  ti n ve  ,   a   n; r e     n n   = "df     ! typ f  e  E lm    B y    a  me  ?e tE lem en  y  a (t    |  "*"  " n d e  n  "           ySe le ct   r l     q  e  S l toAll( |  " *") :  [] ,  oi d  0   =|| t&& A(   t )  ?       eg e( e],n   n   }    u    tion ye (e,  )    r   (  va r     =   0 r = e le n g  t h  ;   n < r ;    ) .  s t ([     a    va  "  t Yge t[ n   l l  al") }   . tbody = ge  o  t =  ge.     =   ge  a  on = ge.th  d,  g   g .  ,.o pti    ge.opt gr op ge. op t   [ ,    ct  m  u  tipe ' lt  '  " "< l  t   " );      r m e   / |&   +;    fn       e,   t,    r  i)     fo r        o ,  a   u    f=  t. eatD umentFa  m     t(  )     =    []      =0,  h =  e .l n t d   ;  d  ) f ((  e[  | 0  =o f   o  bj e ct =  w(  ) S.  g , o n e y        o; esei     .s o )    a  a   f. app  en C d  .c r e a  t  e E  ee nt d "))     .exec(|[  )[  1 ] .to r  se =  ge[s |  ge._d  efa l, a.i n r L u[1    S htmlPe    t  (o) + u[   ,    c= 0]  h    c-     a.las h  d;  S .me      ,     ods ),  (       l) .textC  n nt "  }   e ls     s  h (  t c a  e t  d e(o))  .   x  t   ontn    ""  d  = 0; ile ( o =  p [ +]) if  (r & &  - 1 < S . in r r y o,)    &   .  pu(   ) ;  ls if (l   =  i   ),  = (f. p    h l ),  r pt), l &      ){   c   = 0;   i    ( o  = a[c    e  t s t(o .t y p ||   "     &      (o) }   tu  n }      ar    = ^([   )   ( ?   .+ )  | )    u n c  ti      we )  e  n   !0  u     ion Te( { re   tu !1 fu n ctin Ce(   {  r tu         === f    ti n()     tr {  retur   .    Eemen } c   (      }  }()   =    f o c us"   = }  t n    ,   t , r i, o     ar       if ("obje  t"  =  pe   )  {  fo   s   n s  ing" ! ty  eof   && r =   |  , n=    o   d 0       e(  , s, n    t s], o  r urn }  i nu =  r  nll   =  ?  (i      r    v    0) : nu       &  ("srin " =     p e    n   ?    ( i = ,  r o  0   :  =   r , r  n n  =o  0)), 1   =     Te       (! ) r u n e  ; etu     1 = = = o &(  i, i  n ti (e) { ret r n S ( ).off(e), a.a p        um ets ).g  i = a.ui d  | ( a .guid    .u id+)), . ach( func ti on  ) {   .v nt.ad(t   ,    ,  , ) })  f u  c on S ( e,   i,  o         e t (  ,     1 ) S v t.ad e  i,  { namespa c e:  dle:  c  t  on  )    t  n   = Y e th     i)  if 1&  T  & hs[ ]     r.  e h( ve n .s ci l[ i   {}  .  e  eTy p e &e. s p  o gati  on  ( ; e   i f(r=  ca l ar g  mnt  ,   Y .s t  i r  ,  t   =   o( s   i ,  h  is [i] ()  r    n     tt s,       |   t    .s    (   s     , !1)        },       ur e  pm  med iae Pr o p  g  at io  ) e.reet a  )   n && n.value  }  else .l e n g   &    Y t(  i ,   i, {v e:  .e    enttig r( t   r[0 ] , S.Event . rot t ype ),  r.  l i e),   t h i s)  }) , e s  mmediat r  pa  a   n())  }  } )  :   d  0  ==    ,  i    &  &     ev   t.ad     e )      S .e v   n   t  =   l: }   d   func      ,  , i)  { a    o       s   , , ,   ,  d   h, g,     Y.g (t)     (V( )      h an &   (n   =  =  n ) .h ae  r , i  o.sel   or) ,   i &&   match e s     ector (r e , i ,    n. u |          .gu i d++),   = v.evets   || (u = v.e    n t  bj  ct rete(u ll   (   =   v .nl e     (=  hande    fun  i  n   )      r  r  d in d "!= t  eo f   &&    S  vent.trig  rd != .t  ?  vn t.isatc h. a   y ( t   ,    arg me s    oid   } ,l = (e =( |   ) ma  ( P  |[" ])  e g h; w hil l -)  d =  g  = (s  be.  e  c(e[  | [  [1 ],   h  =  ([2  | "). split("." s rt(, d && (f =  . e e .spcia [d  ]   d = ( i ? .d e l   ate Typ e : f     |  d,    . v e nt. se l [d        = et   { ye:  ,   i p  a   h  dl e   , gu d n g ud ,  e e     , n   sC on t    & S. xpr m  c h. needso n tex t i , am  sace h.joi( . "   o), p =ud )  | (p   = u [ d] =    e e gate C o   t   = 0, f .e p& & !1 = f .s    a l    t  , h, a ) |    t.  ad e n t Liste ner && td  t   tn   d  a)), f d d  & &     .dd.c ,   ,   hand r.ui d  | (  d e r. gui=   ud   . le( p elg  eCoun t +, 0 , c   :  p. us     , S  vt lo   ] =   ! ) }   }    e o : fu ction( ,  t, , ,  i  { a a,  s , u  l, , f,p ,    g, v  Y  Dt      et ( ;  (  &   u   =  v.e ven   ))     l   t  =   (  || "").match(P) |   .ength; while   l  )  f  (d =  g =   = b  .ec([l] || ])1 h    (s[2 ]   ") .s  p li t    ". "      ),){  f  = S.    n    ci al[ |   , p   [ d =   ?   l eg  e     : .b  T   d     s =  [2 ] &&  n e R  gEx ( "| .) + j    "   ( . \.|)")   (\  |$       = =    p. le  g t ; w  (o --) c=  o]  !  g !=    or p ||      . ui d   == .gu id  | |  s & !.  t( c. n      ce   )  || r &  r  !     ct o    &&           ||    !c. s elct o   |  |    (p.splic (o,  , . el      dle t   un   .remo  ve   .move a l  ,   ) ;  & p eng t    r w n &&   ==   e  d w .call(,  ,  dle) |    .remov e nte, d    de),  dele   ])} l  o   din u  S .e v . e  o  e(e  d +  l ]  n    !0 )   S . i Em t Oj ct(u ) &  & Y. ve ( e   "  a  l      t s")        i    c h  :   fu    t io (  e   va r  t, n  r , i,  o, a, s=  A rray(a rgu men .   gth ), u =  S. e en t.fix) ,     =(.g e   t( s, "eve nt ) | |  Object. eat e(n     [  u   ype] ||  []   =  et.spe c [   pe ]  {};   f     =  u,   = ;     <   e et; t + +  t  = uen  ts [t ]; if  u.   e l  ate aret =  h   s ,  !c .   spa tch      = c. p   D  t ch ( i s  , u))  a    . v t   a ndl     all(ts,      , t 0  i l (  = [++      sP        to ppe d(   u.     rentTa   = i .e   n=0; wh     =  i h   s[ n    ])    !.   ed i  at e r opaao  p   d  ( )) u.rnam  e p  &     ==   m p    c  !  a     ac.tes o  m spac e)    le   j  o    ud     o.daa    =  (   =  .ev   t  . s e cialo o     g   y p   |  | }) hnl |  |  nl  r).  ( .l m ,   s     =        )& (u.re tDefa   (),   opPro p a gaton ))   }    r r  p t Di  p  &     sDis pa t ch ca  his,  u ),  esu     nd e r s:   u  n e ,  v  n, r,  i ,o,     =  [], u     elegatut,l   .arget; if (u&l.o e T e &&  !(   i "  e.t e && 1  < = button ) ) r ( l != ti; l = l . arentNo  d   h )if  ( 1 ==  n odeTp   ("cl ick  !== etype       ds   bled )  for     [ ],  a    0 ; n <    n +) v  id  == a i = ( r           sl or  + ""]&(a[i  = r.ne o  ex t? - <     s )   .i n  (  fin d(i          [l].n  hi]     pu r ); . le gt   s   h eem    l h   s: o })}rt u r    t h ,  <t.l n t & u   em  l,ha  rs  .  e (u) })  s      u t on(,     bj     d f eProp    . prototy    , {  en ume b        l       !    ,  ge    un in() {     i f(tis or g in aEent r e     e(  i .r   na  nt)    : funct()    i ( is    in lE  n  )  re t  is i  lEvent [    un c t ion )   Obj t  d f i nePo  rt y(this        rabl :    n igu   e:  ! 0, t b e   0 val    )  }   )   i  nct in(       tu r e[Sex pd  ?  e   :     n   .ven (e) ,  c  :   oad    u e!   },  c lic  {  e t up nct (e){  v  = t s    e  t  rn e   e  .t  e) &&t i      A ( t,  "    t) & & Se(t ,       we!  } t gr    f uct ion)    r    =  this | e; reurn pe .test(t.y   & &        ck  &&(, " nu  "  &&  Se(t, "c k )     efault: fu   ion (e    ar t   ta     tu pe.te    tye &t.cl ck    t "in t ")     Y.g  e  t  cli c k"   (  " ")  } },  be f  n  a d: pot s c  fu n    n( e { vo d =  e e sul  eo   na ve  n   (e o  iginalE v e tr  al e =    sl    }} ,Sre mo  ent   ct  ion( ,    n)        nisen       e e e veti t  er( t ,    , S . Ee t  nc i (, t   {       ii s e o SE  nt )   e n  ewS. v    t )    &  e  p ?  (t his.   a ent =      hs.  t y pe = e.ty t s  s a u   Preve nted  =. f Prevnt  d   |   voi    == .     f ault  P  v en ted && !1  =     u r   ale   ?  :   T,    hi    arge t      ag et           e.targ.      .t ar  g e  t .   a e Node:  e.t r    i  s.cur e tT      = e. u rrnt rg   e at  T ar       atd  g )    hi ye     t &    e nd(this ,,   s im  St am p  e    & & e.time Sap |    t e o   ,  hs[S.exp       !  }, S. ve .  o otyp  = co n st r uc t o r: .Event , Df   u ltP re v ene d: T e,    Pr opagat io S t   p d :  e , i s mi P o a tSoppe  : T,is S   ated:  !1, pr ev entD    a  l  :  fu n  ct  n ( ) {  e = t   r ig l E ve t;    t  h is.isDefa ltPr vntd      ,    e  && th i s.is m  at d  & &   . pre v t D e  t   } ,    t pP r pa tion: fu n   ion  {  a r   e =    h i.o gil E v  tthis.is P ro ati S o p e d =e,  & ! hs   S lte  && .s t     op gtion() , med  a t  eP r a gat  io  :  f n  ti    )   v   e    th  o       t h s .isImmdi    P r  pa   gtStop e d      &      . Si   t       p mm  i e  r a ti   ) , his. st p r   t      )  } .ea        0 b  !  , cancl b  e:  0       g   ed     c tr lK ey   :     eta i l :    t e:     ,   aKe y   !0 ,  p g X     Y: !   s  h i   K e y : !0  i   ,   a r"      0, cd0, c    rC : 0 ,   e y  :     !  , k eyCod       !0, butos:   c lie  !   cl   0,o    !0 , o f :    in  eId  on te rType:   !0   cen   0    s cree  : !0 ,   ar  e   es :     l me n t:  ,  touch : ! , hi : !0},  . vn p   S.each(  f  c   f  u    u "f   ou "} f  c  io      S ve   t.  l    se  t  p   f  ti n   (   eturn e(hs    , C ,  1} , t ig g e r n c   i n  ) { r   rn  th ,      e  !0 } ,  _d ef u l  t   n t i n){       0    legateT y p e:   } })  . ch ({ mo u  ent r :o e ve   ,m   ea   "  useo t"    n t re   t e r "ont    o   r    in   e r l e    "  o   e        f ct n   i )    {    S .ev en t pe ial     =     d el  a t T ye :   ,b d y e:   ,  a     e: f    io (e { va   t ,  n  e   . re a dTarge t ,  eh ndle Ob  j;  retu   r      (==  t his |S. otain  s hi s n)  |  ( e.  e     rTy      a d l e   p       , argume      e .type   i)      }   ), S . e  n   : uc o    e  n )   r           t, n,  r )  ,  on functi on( t  ) {       e th      t n,  r,       f  t ne       n )  {  arr i  e   &&     e f   l  &   e.  le   turn r  = e eOb  j (e.de le g t Tag o   . e s a  i gT y p   + ".  +  .amesace : r. rgTye   e  ecto   ler), this ;  f o e  =   of  e )  {  fr    i i n  e   .offe [ i]  eurnti     etu   !  !  &&      nct n"  !=   y o f    ||(   =   , = o   d  0     n   && (n   = Te  )      a ch un ction( )   S n t .rv       , e    n ,       } } }           = /<  p t  |< s l | ink/ Ae  = che e \ s* (?  ^ = ]| =\ s*. h ed /i ,  N  /^s* ?  \[CDAT A\ [|--)|(? \ ]| -     ;  f ije (e , t)   etrn  A ,  l ") & A    ! =    d T     t : t     f  s h i l d,  "r& S   ) .  h d ren (" t b o dy )[] | |   e  unc  o    e(  { e    n e .  ype = (null !      etAt r b  t e("ty"    " +  ty , e    } f un ction q       r etu rn   / "  == e . ye| ""  c 0,   ?  .ty p e =  e.  e.s ic (5)  :   e. mo ve A t t ri e"  p ) , e    fu tio L e  e ,   {  n    ,   i,  o, a , s; if (1   t de T   ){    f   Y .aD a a(e) &&  (  s   .   (e )   eve  t  s  )  fo ( i     in .  e m    ,  "ha nde   even "       r   = 0,    r      [i. e g h     ; n  + +)S   .   ( i,   i[ .has   ta     c se), a = .t  d  ( {     o )    set(t,  a)  }  n t i  o   H e( n  r , i,o)      =g r) ;  va r  e,      a, ,  u,       =  ,  f =   n .legh ,  p   f   1  d  =  r[0     d);    h     1    <f  "string"       f  !y c hec lo e      & te d)  e   ch  nct  io    r  n  eq   (e) h && ( [ 0]  . ca l        t   ())  He(t , r  i      };  f     (  =   ( e =  (r  [ 0] . w n r Do  cumen, ! 1   n  o) i r h     1    =  e ci dd.n   &&  e =t), t | o)  or (s =    =     ( ve( e,  "srpt") De).e g h   c        c   !       S c l  (u !0 !0) s & Sm rge(    u  "s    t)   c  l(n[c]  ,    ,      f (s)  fo  =   a [  a gth  wne o     ,    . m a p(a,q  ),  c = 0; c  <;   )  =   a   est(u.t y  |" &   ! Y.a essu,g o b a  E val")&&  S c on a  u & (u. c  & "m  u "  =  u   e | | "" oLo  e  a  ? _eva l & &  !u.n    ule        Se l Ur u . c             o    | getAt      " nc  " }  l )  u.t e xt ntent e p   ace (Ne, ")  , l) )  } re   rn  n } fnct    O(e,   n) {   (var  r,      f l    t ,    : e, o =   ull  != (r    i[ ])    o   + )    |  == r.no d e  pe || Sc at a(e( ,.  eN d    & (n    e(r)   ve r , s c i p " )  . re n  ode.rem e  )  e  ur e } .ex e   n d {h t mlPref  r: tio  e) {   r eturne   }  ,   l o  c one, ,      vr  i   o, ,s, u, l,    c  = e. n o de (  , f   ie(e); f  (  y oClon Chec k ||      = eno d  eType &&   1 !    o d Type ||  S  XLD  ) o       =ve c), r  0,   i    v (  .l t   ;r i; + ) s        = [ r    i  0       " ==     = u. n  d    me .t Low s   &  e.    s.type)    ch c e        ch  e  k d      "inpu   !   = l  &  eta r " !==      || (ud ultVal       tVaue) ;  if   )  for   o |   ,   a = a||  c  ) ,   = ,  = oe ;     i   r + )Le(o  , a   ]  el  (, ; tu  n 0  < (     cri t ")   ).l en gth    &    ( ,  !  f  & ec r i  "))    ,   le   ta:    ncto )  {  ovr  t ,   n, r ,  i  =    S .   tsp cial,     =   0; d   !   = n)   + + ) f (n {f(t= [. a  n         i f (t.   e  t  s) o   r  n t . en     i  ]   .ev tre o   r      e       nt    r,.h dl e n[ Y. x p   = vi  0  } n[Q. ando ]      n .xp d  o]  =     voi )    } ),  S.fn.e  x te  n   d e  a c   u i o      { ret ur n Oe(t hi s,   ) , r e o      f n c  )     turn  Oe  t   i,  e) } ,  tex     un  t on(e) { r e r $(t i    tin  {  e rn v o d 0 =     ?     .  ex (th  hs.  p   y  acfun c o( { 1 = = t    .  d T e&     1!   th .  y e    9  ! ==    y  | th  s. text  ent  } }   ull,,  rg me nts .le th)},   appe nd   ction() {  r   n He(thi s  a  e n s unc tine {   1  !==  t .   d  p & 1 1  tis  n o dp   &  9 !=     . e   p ||  je( thi   )p  dC  il d(e   , p repe : nct on   {r u rH ( i, r men t ,  f     o n (e) { i(1  =  thi no dTyp e ||      . n deTyp | |   =   t his od  eT ye    t  (     ;   t i  s ertBfore   , t. fi     ld)  )   oe     ()   { e u n  He(  i  ,argume t ,  func io n( )  {   a e   d   &&   th i   r  ent  i n efor    s)    )   } a f  r : f u   n c  on)     u  (is,  r    s   n  on  e){   . a rnN d & & t s.pa  t Nd.       o   th    e xt   l g)     } emp  :   u   t i o ) { o (a , t   =        ! =  e =   t his [ )   + 1 = =  e  n Ty   && (S c ea nD a  ( e(e, !1 ) .text   e nt    "")  ret  t h  s, ln u io n(e,  t ) { t urn  l !=    t n   t?      t ,  this m a p(  o  etur S o i e    } )    h tml: funci (e  r   (h  fun io(  vt =  t hs[ |  n   , r th i s.  e ng th if   (id 0    === e  1 = .dTyp e)rtr  .in eHM L;   f " st  g = p  &  . e ( &  e [( d . e e (  | ["" , " " )  1 .toLo we rCase()] ) {   = .   t P   l   e ) ; r {  r (  n <    +  )  1  == ( t      i  [  | |  { )n d        . cenDa t v  (      1  )  i e H L    ; t   }    c           & h i s  e  ty( ) .  pe d(e )   } ,    u  e, a   nt s len gth)   ,  p a  c e W i  t  h  :  f  uncti   ( {  varn   [; r et    He(t his ,  argum ent s uctio n  {  vr t =    s.pa  No    n  ythis  , n) <   & (   l e  ata(veths  ,  t &&   r epl eChil d   thi))  , n)   }   each({ appendT   p d"  pr  dT:"r  d ", insertBef r: ef o  e,    ertAf te     ft ",    c  A ll  "  l a  Wi }, u  t on (  a)    n    ] =u    n(  e    ar  ,     [] ,   S( ,      =  r l n    - 1 , o =  0  =  i;   o  +)t o  = =    i  ?  his : hi   c lo  !0     S (r[o   , u.ap l  ,t.g ));  ret    th s. p  ush t ck(n)  }  vr e     n ew    e x ("  + ee +  ) !px a ] + ,   "i    ,      fu   n  e   vr    = eown o  u      u tView;  rtur &       r   | | (t         et Co  pute  le e )    } , Me=  funci (,   ,    r i,  o  { ; fo r ( int)   o [ i ]   e    t      ]e    l    [i  o r(i     r  =  n.calle)   ) .tyle    ]  =    o [ i]    e  u    r },  Ie =    E    e.    (  "), "   ;  fnctio We     ,   ) { v a  r    r ,i   , s = es t y e;et n(n       | e(e)&      n  .getPrope rt    (    n[    e e      a =  .    le(  )    !y   x B xt y e  ()    &   Pe.test(    I e. test(t  & (r    .wth ,   i    s . mi n W idth , o  s  xd  ,  s  in Wit   s.max W i dth    s.w       a    a=    t , s.wd h  ,     h   i   . m a  id h = ) v      a a +  " : a   }  fu n c   n e(e,     t urn  et fn  n()  i  !e ( ) ) ret  hi      py is,   m n    de  lete th g }   }      tion  ( )  {  fucti   e {    l) { u.syl .  ssText =   p o  i tio  n :a  olut  ;  f -111     t  :   ;m gin- t p    px; dding:0;bo r  r:0",l. s ty l e.  sTe x   " o ion:r ti  ipl :bl ock;o i      ord -   ov er w:scrolmrgi n : auto;borde  r :   padding:   wi th 6%;t    :1%"   r e. p p endCh     u) .appe d C  d l);   e C t Copue t   le ); n  =    " 1%  !=    o p  s = 1 = = t .ar gi  L  , l . yl . right    0  ",  o = 6 === t(e.rig ht ),  3   ==  = t  ewidh), .   . s ition  = "absolu  te  , i =    o  s   t i d th /   )      re .re vC hi  ( u) , l   n   ll  }     fun    i  o t(e) {  reu r n     .r un( s     t  ) }  v ar   n,  r  ,o ,   ,   E.cr  t  em en t( d i v"), l= E. cr ea  e E l e m ent ( " di v ;.   y l &    t yl e.   roun dC ip =  on  t bo x ",  l    eNo e     .styl e.b ckg u dC  p  = "   ,   y .lerlo  eStyl e      n  tent-box === l  t    eback grond C l i   ,S.exten ( y   ,  {    bo    i Reli a    cto { ret   u   e( ,       pixeloxS y les      o n( )   {   r t u r n  e(       i xelPo i ti o n  u  o()   { e  t   e (    ,  re bl eMrgi f t   c n    {  retu        c    Se: f u n  tio )   rt ur e)   }, eli a   le  r  i  e s ion :  fun     ) ar e , t    r;    et  r n nul l        &    e   =  ret  me  "     ),      a t    e ment ("  r      = E c e teEl ement (  v")    l e .     x t  =  p ito :a so  lu et:   1  11  ;borr-col p  epar t e " ,   . st yle . set  bo  :1px ld "    .sy    he i t =  1px "n l e    t =   " 9 p"   n. styl e is ay  =      c       .ap e   h i l e) a p   h d(t) .  ppenChd  n) ,  r =  C  . e t C m   tyl e  (t)   rs  eIn  ight  10 + a  eIn r.bordr To  p Wi     )  parseIn t r . o  derBoto  m With 10)   = t. f fsetH i ht ,  . r emvCil  )   }   }   v r B  =   ["Web ,  ",  , e  =  Ec at  e Element("d iv   ty e, _       f unct n e() {a  t = s   ]   | | _ e    retur      $e   ?  e   e ]   = uncti o n(e)  var t=  e [0 ].  Upper Ca s e( ) + e.sli  (  ), = e. l eng t     wile  (n--) i f  ((e     B  e[n  t)  i n e  ret  e   e |     ar U e   =     on|    ab l e(? !  c [ea ).+)/ Xe      /^--/ ,  e    posit   " bsolute vi s i bil y: " hidde " , d is ay " b   k "  ,  { let te Spacin g:  " ", fo ntWeg     :   00   ;  f  ction   Ye , ,  n)   { vr r   te.exe ); return r ?  .      2 ] - (n|     +  3]   ||  " p x")    }f n cion   e  , n     i  o    r a = wd   t   " = =  ? 1     ,      0 , =      (n ===     order" :   contnt  ) r t    0; for (;   a   <  4 ;  a   +   n == n && u + =   S .   ss(e,  n + ne[a    i)  r?  ( "conte "   = == n &( -= S . s s( , p   d din" +  ne   ! 0,i)),  m a g  n  =  &&   -= S.s (e,  "b r r   [ a] + W idt h ", !0,   ) )  :      +S.css(e,  "pad d i    +  ne [a],  !0 ,  i) pain "     =     =    S.   s( e ,  b re"+  ]  +  " Wd  " ,  !0 ,i)   +=  Scs  "b or de r  "  +   [   ]    " W d   th ", !    )); return   &   0   <= o   &   u + = Ma h.ax( 0 ,  M a   th    cei l(e [" o f fse t  " +  t[0 ]       p p a     ti  ce  ( 1 ]    o -    s  - .) ) ||  0,    u  tion  Je(e,  t ,  n) {  var      e e) ,  i   =  (!y.bxiz  geliabl ||  n   &  &  "bo  de r   ox" === S. css e,    bo S  i  ng " ,     ,     i,  a   e(  e, ,r ) ,  = "o fset     ]. t U   p e  C  a se  ( )      t .s l  e  1 ) ;   i  f    e.test  ) ) {  if  (!n)  urn  a    =  "         ur    o  izi ngReli abl( )       ||  !y. r  a Tr D i   i s()  & &   A( e,       ||  "u    "    =   a ||  a  s  e F  o  t  a )  & " inli n e ==    S.cs s( e  ,   " dis p  ", ! , r )) &   e.etCl et R     s() l n g   h  &&i   r e    box"  = = S .css(e ,   o xSizi n "  1 r  ,  o  =      n e) &&  (  =    )), (a  =   p ar eFoa t (a )   ||   0)    Q  (,t       | | (i   b der "    co nt  nt ",   ,     a ) +  "p x  "        io n K e ( , t,n, r,  i )    {  re  u r   n     w     Ke.  o totype.   i i    e        ,  r,   }   .x  te n d{ cs ook    op  t y:  {  g e:   f u n ctio   n (e  {  f      )    ar   n    W    (, "o pa " r   turn  " "     n ? " "  n    }   } }, cs N  m be  {   animat io ati oCou n t :   0, c olu m n  Co u nt:   ,  i l lO city: !0,  fe  r o: !0, fle xS  hr i nk !0 ,  f   ntWe i gh !  r idA a:  ,    d   n:   !  ,    g  r C l u mnE  nd :    !   0 ,grid C  lum  n S t a   rt:    i  d    !0     g  r  wE   : !   gridRo  t r t :    0    li  Height:     ,  o p  ity : !0,     rd er:  !, o  h an  s :    !0,   w iow   ! 0,  d  :  !0,    zoo: 0 }, c so ps:   { , ty f c io,  t  ,  ,     if  &&  3   ! == .nde p &&  !   =  e  eyp   &e. t l  v  o ,   s  =  (t) , u =  t (t   =   etye; i(  |(   ze ( s a= .c ss Hoo    t] || S s   o o s],  v  o id 0 == = n)  turn         a && void 0 !== (i    =   a. e t (e,  !     : [] ;  " stri  ng "  = == o   =    t y pef  &     (   =        ex  c( n ) ) &   [1] & (n    s  e ( , t,  i) ,o=    um b   r" , null ! =   &  &   n = =  && ("num ber" ! =  o   |  |   u ||   ( n + =  i i[3 ]     Sc   u m ber [    ?  "  "  : "   ,  y.c le r l  on e S  y    " " !=      ||    0   = t.inde   Of " backg  r oun d"    t   =  "in h  ri "), a  &&  " et" in  &&   id  0  = = (n = a s e(  ,   n ,  r)) || (u ?  l. se tr p r t, ) : l [       )    }  } ,   cs   f  t  on( ,   t,n , r) { va ,   o, a,  s  =   X ( t);  return       t (t) ||(t = ze(s),( a   . cssHooks[t]     S. c ss   oks[s]& & "ge"  n  a  && (i = .g  ( , !0 ,   )     === i & (i  =  e(e, t, ) ,  "o m  a l" ===   &   i nG  &&  i = G[t ]),  "" ===n   |  |   (o =   p seFloa i   0  = = = n || isFinite(  ? o |      i)  : }  , S.eac  h eight ", "widt h " ],  fu tin  e, u) {  S s ks[   u=   t:  f u  nctio n(   n)  {  i    t) r tu  n Ue.tet(S.cs(e, "d s ly" ) ) ||  .  g etClient ct s ( ). le ng t h &&  e.ge   un  ig Cl i n e ct () .  id th   e( e, , ) :   Me(e, , c  n ()   turn Je(e , u , n)   })    s et: functi n  e   ,  n)  {  va  , i  = Re e) , o=!y.sc  r o ll b oxSize()   &&    "absolute    = =  .posi  ion,          (o ||      &&  o r rbx"      . css(e   " bo x S   i "    ! 1 ,  i  , s =  n  ? Qee, u,   n, a,  i)   :  0    r  e t ur n a  &&  o   && s  -= M   ceil(e["o f  s "       [  0] .toU p  r C a   ()+   . sl  ce() - parseFloat(i[u] )  Q (   u,  or der",  1,  i )   . 5 ),  &&  (r    . xec(t)) && "  " ! ==  (  ] || "p x") && (es l  [u ] =   t,  t = S. e  , u) ,  Y  e(0 t, s)   }   }   }), S. c  H o k s .ma inL ef t =    e(y. r elia b l  e  Ma rginL ef t , f  ct ion(e , t )  {if (t) ret r   p  s e  F loat(Wee, " m a rg nL  eft") )  ||  e . getB o nd inglientRe  () .left - M    ma rg  L    t :  0   }, u    ion( { r et u  r n  e.   g   eto di n g C lien  e t() .     ft })) +    x" }),  S.ac h({  m argi  n:  "",  pa    i n g     , bo rde r   "i t  h"  ,unction(i,   )  {S .c sHs[i +  o  e    n d: nction(e)  { for ( r     ,  = {}, r   s tr g = ty f     li t "" )    [e] ;       <  4 ;  )[  i   + net]     [t] | | [ ] |   r[0];   r turn n }   },  " rgin" !   = = i && (S . c ssH ok  i   . et   =   Y)   }),   S . fn. e tend({ css  io(e   )   { r et n $( th is,fnct ion(e, t, n   v r  r, i    o      ,  a    =  0      rry   Arra (t ))    o r   (r =      ( e),    =  t .len gth; a  <    i ; a+  )  o  [ t[ a ] ] =   S . css( e,  t [ a] ,  !1, r   et ur n o }r t urn   v o    0 != =   n ?S     ( e, t, n): . css(e,  )  },   t , 1  aru m ents.l en h) } }),  ((S. ween = Ke) . p ro o      =   { c onstr uctor: Ke, init: fu   ti o n( e ,  t,  n, r, i, o ) { ths.l   e m = e,   thi s.prop =   n      s.es in        | S sing ._   defaul t,   s o  pt i o n s   =  t,  s   t ar t = t h   i s. n o w   =  scur(), t hi s. e  nd = r,  t h  .n t  =   o || (S. s  Nu  m  er [  ] ?   ""   :  "  px") },  r:   f u ncton  (     = Ke.pro pH ook s[ thi pop] ; rt r n  e &&  e .g et    e. t ( this) :  . r op H o oks. _d efa u lt.get t h i s  ) }  ,     r   :   fun ction( e ) {   v   t  n =  e.propHoos[t s rop]; r turn   his   pt i o  n s . d u a  ion  ?     t     p os   t    e a s i ng[this .e   ing] ( e   his.o t ions.d u ration  *  e  , 0,    ,   th    s .  optio n  s   . du ration)  :  this.pos  =  t  = e,    hs.now = (t s  . en     this.star t)  *    t + hi  . s ta rt,  thi s.  o  p t i ons.step   && t  h  is .opt     s ste p.ca ll ( thi s . lem,  h i s .  n o w, this),   n & n.set ? n.se t ( his) :   e.p rop ooks._  d e f  u lt .  s  t( t   i  ),  t  his} ). ini  . p r o t o t y  p e  =  K e . p   ototyp e, ( K e.p r opHooks =  {  _  d e f au   lt : { get: fu n c ion (  e )  { v ar t; r et urn  1     = e.elem.node   Typ e  ||  ull   =    e .  e  lem[e.prop]  & & null =  e. elem.s t  l e[e.pr  p  ] ?  e.el em[e.pr op ]    (  = S  .  css( elem ,     epro    ""))  &&     " u " != =     t ?  t :  0   }   s et: f unction (   e  )   {   S . fx.step[e.pop] ?  S .fx.  te p[e. pr o  (e )  :  1  !  == e.ele m. od eType | !S.  c  s  sHo o k s [ e  . p    p    nu ll == e  .l em.style e(e.prop)   ]  ?   e.elem[e.op ]   = e. now : S.sty le ( e.e m, .prop   e.o w +   e. u ni       } ) s   cro  Top =  Ke.propHook  . sc rollLe f t =  { set :  u n c o n( e {  e  .e lm.node T  y   pe && e l  e   m p aren  d e  & &   (ee le [e.   rp  = e. w     }   }  ,  S.easi  g  = {  ner  f  ctio( e ) { return  }, s  : unctio    (e)    r un   .5 -   th.os *   h P  )   /2  },  _ d efault:   " sig    .fx =    p r ot tp   n i   t ,   f    st ep   =    };  va r    Ze, et  t, nt,   r t  =  / ^   ? : t o  ggle|sho |h i d  e) $ /,i     =  / q ueueH   o ks$/; fucti    o  ()      {      e t   & &  ( !     ===  E.hi dden &&     C .r   e questA i m  a  ionFra m  ?   .r eq u s tAnimati o   r ame  (  t) : C. setT im eo u t  (  ot ,   S.fx.int erval),S.fx .  tick()) }  f u nct i o n  at() {  r  e tu    C . se tT i mout(functi o n ( ) { Ze    o  id 0}  Ze   =   Daten w (  )  } uncti  s t  (  e   t ) { v a r  n,  r  = 0, i = {  he ig ht:  e } ;    o (t =  t  ?  1 : 0;   r < 4; r +=    2 - t)i["margin" + (n  =  n e[r]) ]  =i  " pad d ing"  + n ]  =  e ; r t ur n   t   &  (i. opaci t y =     i   .wid t h     =   e )  ,    i } fun cti    ut(e,      t ,  n )  fo r   (var  r,    i   =  ( lt .tweene r s[ t]  |  [    ] . concat(lt . t ween ers [  "  *"  ] ) ,  o  =  0, a = i  .l ength;    o   <   a ;  o ++) if  ( r  =  i   [o ]. call(n,  t ,    e  ) )    r  turn r } funct   i o n    l t (o,   e, t) { var  n  a  ,     r  =   0,   i  = l t.pr ef il t er s. l   ng  th,  s = S.D eferr ed)   .a  lwa  ys (funct i on ()    {    d  e  le t e  u. ele  m   }), u    =  fu n ction( )  {  if (a)  retu r n   ! 1;  fr  (  v   a r   e     =   Ze || at( ) ,  t  =    Math.max (  0 , l. ar tT ime +   l.duration -  e),   n  = 1    -  (t / l. duration  |  |  0), r = 0,  i  =  l  .  tw  ee ns. le  n g t h; r  <   i ;  r+  +  ) l.t ween s [r].run(n) ; r   et   urn  s.notif yW ith(o, [l,   n , t]), n  <  && i ? t   :   ( i    ||  s. n otifyWith(o,  ,  1   ,  0]) ,  s.r es    ve W    t h(o,  [  l] ),  ! 1 )  }, l  =  s .p ro m ise( {  e  l e  m: o, p r o  ps: S  . e  x t e n d({} ,     e ),  o p t s :  S .e  tend(! 0 ,  { speci  a lE asing:  { } , easing: S.eas in g._defa ult  } ,   t), ori gina l P r oper ties: e, or i g inalOptions :   t ,   s tartTi me: Ze ||  at()  ,  d u  rat ion: t .d u rat i  , twe en  s : [] , c r e a  te  Tween:  f  u nc tion(e    t  ) { var n =    S   .T  w  e   n(o  ,  .o pts ,  e,  t , l.opts .s p ecia l  Ea sing[ e] || l .o pts .e asin g); r e tu rn l  .tw ee ns . pus h(n),  n },   st op:   func  tion ( e) {  v  ar  t  = 0 n  = e  ?  .t weens .len g    th : 0 ;  i(a  r et ur n thi  s;       f   o r (a = !0;  t  <  n; t++)  .t  we e ns[t] . run(1);  r e  tur n    e   ?  .n i With (o, [ l     1,  0]   ) ,   s .reso lveW it h(o,   [ l,  e]))  : s.r eject Wi th (  o,   [l,  e]) ,   this } }),   c  =  .pr o   ;  r (! f u nction(e,   )  {  va  n,   ,  i,   o , a;  for (n      e  )  (i  = t[r  (  n  )  ] , o = [n],  Ar  a   y. is   r   y(o )   &(i   =     [1  ],  o  [n]      [0 ]),n   ! =   r &&  (e  r ]      ,  del e e [ n ] ), (a  S.   c ssH ooks[r] & &    "    e x pa nd "  i n    a)  f  r  (n     i n o = a. e xpand   ( o ), delete er ] o  )   n  in e | (e [   n ]  = o[ n ] ,    t[n] =  i) ;  e ls e    t[r] =  i  }  (   c ,   l . opts . seci alE  asn g); r  < i; r++ )if   (n =    lt . p r  e  f  ilt ers[ r] . ca ll(l, o,   c,    l .opts  ) return  m  (   n .  top)   && (S. _ q ue u e  Ho ok s(l.el  e  m,   l.o pt    s .  que ue ).   op     n .s t o p.bin d(n) ),   n; re      tur n   S .map(c ,  ut ,  l), m(l.o pt s.start) & &   l  . opt   s.s t ar t  . c   l l( o,  l   ) , l.prog  r e s l.opt s.ro g re ss) .d on e (l.opt s.done, l. o p t   s  .c om  pl  ete).fail ( l.opts.fa i l) .  a lw a ys( l.opts.always),  S.fx.ti m er (   S . extnd(u,  {  e  l e m: o , anim: l, q u e ue:  l .o pts.qu  ue   }) ),   l   }   S .An imat io n  = S. e xte nd(lt, { t w een ers: { "*" :  [fu n c ti o n(  e  ,   t ) { va r  n  =    this.crea t T w ee n( e,      t ) ; retur n    s  e  (n  .e le m , e, t e. e e c(t), n),  n }]  }, tweene  r: functio   e   ,      t) {   m(e ) ?   ( t  =  e,   e =    [  "*" ]  ) :  e = e .m   atch(P);   f  or (  va   r    n ,  r  =  0 ,  i   =  e. len  g h;   r  <    i;  r++)n =   e[   r] ,  l  t.tw ee n ers[n] =    l t .twee ners [ n]   |   |    [] ,    l. tw ee   ne r  n]. un  s   h i ft(t) },  p r e fi lt er  s  :   [f u n ct ion(e, t,   n  )    {   r    r,   i  , o ,    , s,   u l,  c ,  f =  "  w idth" in t  | |    "he  i   g ht" in  t, p  =  thi s,   d  =  { } ,  h  =  e .s tyle,  g  =  e .n od   eTy  pe  && ae(e), v = Y. ge t(e, "fx sh ow"); f (r in .u eu e   || (n ul l == (a  =  S._queueHoo ks(e, "fx") ).u n e ued  && (a.un queue d = 0 ,  s =  a.empty.fire, a.e mp ty.ire = fu n ction() {  a.unqueu ed   || s()  } ) , a.unq u eu   ,  . a lw a ys(fun c t  ion() { p.alway   s(function  ( )  {  a. u nque ued--, S.qu e ue(  e  " f x " ).lengt |  a.em p y i re   ( ) }) } )  )  , t )  if (i = t  [  r ],  rt .t es t( i)) { if  (de l ete  t   [  r ], o  =   o    | |  t oggl e"  ===   i ,  i === (g ? "hi d"   :   "sh ow "))    if ("show" !==   i |    |    !v  || voi d ===  v [ r]) c  on tinu e ; g =  !  0 } d [r ] = v &   v [  ]    || S.  s  tyle(e, r)     }   i f ((u  ! S.   is E m ptyO  b  ject(t))   ||  !S.i  Em pt yObj ect(d) )  fo r    (r i n   f  && 1    = ==   nodeTy   pe  && (n.ove r  f l  =[  h.   o  v erf l   w  , h.o  v   erflo w X , h.overflo w  Y], nul      == (l    =   v & &  v.d  s  l ay) &   &   (  l  = Y.g e t (  e ,  "displ   " )),  "n o ne"  == = (c =   S.cs(e ,  "d i spla y" ) )  & &   (l   ? c   = l :  ( l e([ e],  !  0   l   =     e .st yl e . di splay || l   c    S .c  ss(e,  "di s play"), l   e([e]))) , ( "in l  i ne" ===    | |  "in l in e bl o ck"  ==  =  c && n ul  l   ! =  l )    & &  "   n on  e "  =   =  =  S . c ss( e ,  "float")  & & ( u   ||   ( p.d on  e( func io n(  )  {  h d is p    la y    =  l }) ,  n  l ==  l  &&  ( c  =  h.di p  lay, l   = "none"  = == c   ? ""  :  c)) , h.displ ay =   " inline-block") ),  n .o v erflo w  &&   ( h .ov erf low = "hidden " , p.a ways(fun cti o n()  { h.overfl ow  =  n.overflo w [ 0] ,  h.ov e rflo wX  =  n .over flow[1],  h .overflo wY     n.ov e r  f low [ 2]   }) ) ,  u   =  !1, d) u || (v ? "hidd en" i n v  &&   ( g =  idden)  :  v =. a c ce ss(e ,  " fx show" ,   { display:  } ),    o && ( v. h i dden = !g),   && le([e,  ! 0) ,  p .do  ne(funct i on ()  { f or ( r  in g | |   l e ([ e] ) , Y.rem  o ve(e,   "fxshow" ),  d) S.style( ,  r,   d [r ])  }) ) , u = ut (g ? v[r] : 0, r,  p ) , r inv ||  (v[ r] =   u.s tart, g &(u . end  = u.star t, u.   start  = 0)) }]  , prefilter: f ct ion(e, t) { t ? lt.prefil te rs.u hift(e) : lt.prefilt ers.pus h(e) }  }),   S.spe ed = f unc tion(e , t  n ) { var r  = e && "object" == typeof e   S. ex t end({}, e) :  {  complete :  n | | !  & &  t || m(e & &  e, du ration: e,  a s in g: n &&  t || t & & !m(t) &&   }; r eturn S.fx ff ? r.du ra  n = 0  :   n u   mber" !=  t ypeo f r.durati o n &&  r .durat ion i n S.fx.spe ed s ? r.dr ation  =  S.f .speeds[r. dur ation ] : r. duration  = S.f x. speeds._defa ul t), null  !=   r.queue & & !0 != = r.qe   ||  (r  queue = "fx " ),  r.old =  r.complete , .comp le te  = unctio n( )  { m (r. old ) &&  r. o ld .call(this ), r.q ueue   &&    S.dequeu e (this, r .queue)} , r },   f  extend( {  fade To:  f un ction(e, t, n,  r) { r eturn this.fil ter(ae) .cs "opacity",   0) .  sho ).e nd ().anima te (    op a  c ity: t } ,   e ,  n,   r) },  an im a e :  f un ct io n( t ,   n ,  r) { var    i   =   S.isEmpty Ob je c t (t), o =  S. speed(e, n,  r ), a = fu n ctio n ()  v     e  = lt(this, S .   e xtend ({} ), o); ( | |  Y .g e t (this, "fini sh "))   & & e . s top ( ! 0) }; retur n   a .finish = a ,  i || 1   === o. queu e ? this.ea c h(a) :    his . qu eue( o . q ueu e, a)  } ,  sto  f unc tion(i, e, o)    a    =  f  u n ction(e) { var t = e . stop ;  dele   e.st ,  t ( o )  }; return" stri n   " !=    t    eof   i &&  ( o  = e,    e = i i  = v oi  0)   e && this.queue (   i   || "fx ",    ) , thi s  .  ach( fnct io n() { var e    =  !,  t = n ull   ! =  &  i   +  " qu  eu e Hooks", n = S.tim r  s, r =Y .get(t hi s) ;  if  ( t )   r[t]  &&    r [t].stop && a(r[t ]); else fo r     in r) r [t ]  & & r[t].stop   && it .t  es t(t) && a(r [t]); for ( t   n .l e n  gth ;  t-- ;)n [t lem ! ==   this | | null ! = i && n [t  q ue  ! =   = i |  | (n[ t]. a ni m. stop(o ), e = !1,   .s pli c e ( t ,  1)); !e  &&     d eq   ue u e (th is,  i )  })  }, fi nish: fu  n cti o n (a)   {   retu rn  !1 !==  a  && (a = a | | " fx"), this. e ach(fu n ion ( ) { vr  e,  t   = Y . g et(this) ,  n =[ +  uu  e   " ]  ,   r =   a  +  " u eueHooks"] ,  i = S.timers  o    n ?  n.l   en  g th : 0; for ( t . f inish = !0, S.queue(t hs ,  a,  [] ) , r &&  r.sto p  && .s top.c all(this ,  !0), e   i   leng t h; e-- ;  )i [e].elem = = = th i s &&  i [ e].qu eue   === a & & (i[e  .a n i m.  stop(!0 ),  i.s p l ic ,   1) );f   (  e   = 0; e  < o ; e ++ )n[e] & &   ].fini sh  && [ e ].finish. c al lthis );   d e le te  t. nish   })  } }) ,  S .each([ "t o l e", " sho  w" , "h ide"] ,  f unctio n(   r) { var i = S. fn[ r] ;  S . f  n[r] = funct ion(e, t,   n) { return   null == e|| "boo l e  an"  == typeof e ?  i.a ppl this, a r gu ment s  : this.anima t e ( st( r, !0 e, t,  n)   } }), S.eac h ({ slideDown: st ("show"), slid p:   st ("hide" ) , slideTog gl e: s  "tgg l " ), fa I n:  { opa city: " show  "  } ,   fa deOut: { op ac it   "hi de " }, fadeToggl e:  {  o pacity: t o  g  g le "  } } ,   functi on(e, r) { S.fn    ] =  functi n  (e ,  t, n) { retu n  t hi s . anim ate(r,   e , t ,  n) }  }),   S.timer  =  [] ,  S.   . t  ick  =    function( )  { var e, t = 0, n   =  St imers; for (Ze = Date.now(); t < nl  ength; t++)( = n[t ])()  || n [t ] !== e  || n.splice(t--,  1); n.leng th || S.fx.s t op(),  Ze  = void 0 },  S .fx   imer =  uncti on (e)  {  S.timers .p ush(e), S. .star t() }, S.x.inte r val = 13, S.fx.  start = function() { et || ( e t = !0 ,  ot())  } , S.fx.stop = functio( )  {  et nu  }, S.f x .spee ds   = {  slo w: 600, fast:  2 00,  _ de f ault: 400  } , S fn.delay = f unct  ion , e)  { return r = Sfx  &&  S .fx.speeds[r]  | | r, e  = e ||  " fx"  t  his.queue(e, functio  e ,   t ) {  v a r  n = C.setTim eo ut ( e, r); t .stop = function()  { C.clearTimeout( n) } } }, t  =  E . create El e m  ent (  "i pt"), nt    E  . c r ea teElement("select").a ppe ndCh il d(E.creat eElemen t( " o ption")),  t t. t  e   = "che ckbox", y.che c kOn = "" !=  tt.va lu e, y.optSele cte d   =  nt .sec t ed ,  ( tt =  E.c   eE  l e men t("  input ") ) . value = "t ", tt.type   "ra  o ", y.radio Va lu e  =  "t "  = =  t  t.    a l  u e;   va r  c t,  f t  = . expr.attHan l  e ;  S.fn.e x  t   e   nd ({   attr: functi o n  e ,   t )  {   ret ur n  $  ( t hs  ,  S.a tr  ,    , t ,    1 < ar gumen ts .l e ngth)  },  r em o ve Attr: fun c t i on(e) { reu  rnt h is. e ach (func tion() { S .remov eAt t    th i s, e) }) }  } ), S.extend({ tt r:  function(e, t, n)  {  va r r ,i,  o =    e .node Ty pe;  i 3 !==      o && 8 !== o  && 2  ! ==  o r etu    "   undef ined "   ==  typeof  e .g etAttr ib u  ?  S.prop(   ,  t,   n) : ( 1   =  ==  o &&   S .i sX M LD o c ( e )  |  |  ( i =    S. attrH oo k  s[t. to LowerCase()]  || ( S.ex p r .mat ch .b oo l .test(t)  ct : voi d0 ),  oi d   0   !== n ? null ===   oi Sr  e   m   ov  eAttr  ,  t) :   && "set" i n   i  && void 0   !=   ( r = i. set(e ,  n,  t ) ) ? r  :  (e .s et A t tri b u t(t, n +  ""), n) :  i  && "ge t"  n i && n ull !== (r  = i.gete , ) ) ?  r  : nul l  == (r =  S . find.attr( e,  t) ) ?  v oid 0 : r) },  attrHo   s: { type : { set: funct  i   on ,   t )    f  ( !y .radi oV  al  u e && "radio" == t && A (e , " n   pu t " ))   { va n  =   e.v a lu e;   r t urn  e.s etAt tri b ut e ("t yp   ",  t),  n  & &  ( e . v a lu e = n)  ,  t }  }  } }, rem  ov eA t  t  r:  function(e,  t ) {   v a r  n , r   = 0 ,  i =    && t.m a t ch( P);   if  (i   & &   1   =  e .no de Ty pe   w hl e  (n  i  [r++]) e.re mveA t trib u te(  n)  }    } ),  ct = { set :   f uncti on ,  t,   n )  {  e  turn   !1    = ==     .r  o vAttr ,     n) :   e.set A t t   r i b ute( n, n), n } }, S .   a ch(S.e x p   . m atch.b o ol .sou rc m at c  h  ( /\w+/ g )   , fu nc ti on( e ,  t)   var a =  f  t  ]  || S.find.attr; t[ t ] = functio n(e,  t,   n) { var   i, o  =  t. to  owerCase( );  turn  n |  ( i   =  f t[o], ft[o ]  = r , r  =   n ull  != a (e ,  t,  n)   ?     o : nul,  f t [o]  =   ) ,   r }  }); var p t  =    /^(? u   |s e le  c t | t ext a rea|button  ) $/ i ,  dt  =   /^ (? : a|r ) $ / i ;  f un c tion   h t(e) {  r et urn (e.ma h ( P )  | |  []). j  o in(" ") } funct i on  gt (e)   { return  e .get A ttr  ib  ute  && e.getAttribut e ( "cls s )  |   "  fun c t     ion  vt(e) { r e turn Array.i sAr ra y ( e )  ? e  : "string" = t ypeo f  e   &&  e.ma h(P) || [] } S.f n.exte n d({  prop:  fu nction(e, t)  { return $(thi     S.prop,  e,  t, 1 <  g u ments.l en   gt  h ) }, removeProp :  fu nction( e)  { return  this.each(f un c tion() { d et   this[S .p ropFix[e]     ||  e ] }  }), S. xt e nd ({  prop: func ti o n(e,   t, n) { var  r ,  i,   o = e.nodeT yp e;   i f  (3   ! ==   o   && 8  != = o && 2 !== o) r etur    1 ===  o  && S.isX ML Doc(e )  || (t =S   .p ropFix[t] || t,i  S. p   r o pH  ooks[t]), void 0 !== n ? i  & & "se "  i n   && void 0 != = (r = i.set ( e ,  , t ))  ?  r  : e[t ]  = n : i && "ge t  i n i && nu ll  != = ( r = i.ge t (  e , t))  ? r :  e [t ]  }, ropHooks:  { ta bI ndex:   { get   functio ne ) {    rt  =   S.f in d.at tr( e, "tab ind ex"); retur    t ? pars eInt( t, 10) : pt  . e  st(e .nodeNa me) || dt.t e st(e.nodeName)  &&  e . hr ef  ? 0 : -1 } }  }, prop Fix: { "for " : "htm lFor", "clas"  :  " cl as sN am e " }  }), y.opt Sele c t ed | | (S.propHooks.s ected = { ge t: functi on(e) { var t = e. pa rentNode;  tur n t && t . parentNode && t. p arent N ode.s elect edIndex, null },  set:   f  u nct ion(e) {  v ar t =  e.paren tNode; t && (t.se lect ed Index, t.p arentN e & &  t.parentNod  e.sele ctedIndex) } }) ,Sech "a bI n d e x", "rea  n ly ", " m a xLengt h" , "cellSpaci n g",   c ellPaddi n g ", "rowSpan",  "colSpa n ", "useMap",   "frmeBorde  r" ,  "cont entEditable  ], fu n  ction () { S.propFi[ t s .toLowerC a se()] = this }),  S .fn.extend({  a d dC la ss : funct  ion(t) { va r  e, n, r, i, o, a,  s ,  u 0;  if (mt   re tu rn thi s  .e ach(function(e) {  his).a dd Clas(t. call (  t hi s e, gt( this) )) });  i  ((e  = vt( t )).len gth) while ( =  this[u+])   i f (i = gt(n), r = 1 = =  n.nodeType    && " "    +  ht (i) + " ")  {   a = 0;  while ( o  = e[a++]) r.indexOf(" " +  o  + " ") < 0 && (r + =  o  " ");   i !  = = ( = htr )) &&. s  etAttri b ute" cla s  " ,  s)  }  r e   tu rn t his } ,  r em ov e Clas  f unction(t) { v ar e,    n, r ,  ,,  ,    u  0 ; f    ( m(t ))  r et u r  n th   is.e ach(function(e) { S(thi s ).remo e  Cl ass(t.c al  l( th is, e,  g t(this) )) } );   if (! arguments.l en g th) re t u rn this. at tr("cla ", "") ; if (  (e = vt(  t)).length  while (n =  this[u++]) i f ( = gt( n),r   =  1 = == n . nodeType && " "  +  ht(i  + " ") {  a  =   0; whil e  (o = e[a ++ ]) while (-1 < r.indexOf(" " +  o + " "))  r r ep l ac  e (" " + o + "  ",  " ");  i !== (s = ht(r ) ) && n.seAttribut e(  "class", s) } return  this } ,   togg Class :  functon(i,  t) {   v ar  o    =   typeof i ,  a = "str   i ng " ===  o    || Array.is A rray(i); retur  " o l  e     ty pe    o f   t   && a ? t  ?  this.a ddC l a ss(i) :  th is.removeClass( ) :  m(i) ?  t h  is.e h(fun ction(e) { S(  hi s).to ggleCla ss (i.call(t hi s, e, gt(th is) t  ),  t) }) : this.ea ch (functi on ()   {  var  e , t, n, r; if (a) { t   =  0, n =  S(this),  r   =  vt(i ); while (e =  [  t++]) n.hasClass(e) ? n.rem ov Class(e     :  n. a d dClass(e)   } else void   0 !== i &&  "boole an"  !== o ||   ((e = gt( t h i s))  && Y.set(this, " _ _className _ _ ",  e), this.set At tribute && this.setAttr i b ut e(" cl as s"  e  || !1 =  ==   i  ? "" : Y.get(this,  " __clas sN ame__ " ) ||  "") )  } ) } , hasCl a s : f un c  ti on(e) {  v a r  t,  n ,  r    0; t = " " +e  + " "; whi l e   (n  = this[r ++ ]) if (1 === n.nod e Typ e & & -1 < (" " +  ht(gt(n ) ) +"  "  ).indxOf (t)) ret urn !0; return !1 } }); var yt = /\r/g; S.fn.extend({ val: function(n) { v ar  r, e, i,   t = thi s[0]; return arguments.le ng th ? (i = m ( n), this.each( function(e)   { var t; 1 === th is .nod e T y pe   && (null  == (t = i ? n.ca ll(this, e,   S(this ).v al()) :  n ) ? t =  " " :  "number" == t yp  f t  ?   t + = " " :  Array.isArray(t) && (t =  S.map(t, f u nction (e )  { return null  ==   e  ? "" : e +  "" })) ,  (r =  S.valHooks [t h i s .type] || S.valHooks[this.nodeNa me .toLowerCa se()]) & "set" nr &&     void  0  != = r.set(this, t, "v a l ue") || (th i  v alue = t ) )  }))  :  t  ? (r = S .va lHooks [ t.t y pe]  | S.va l Ho oks[t.nodeName.toLowerCa se ()]) & & "get" in   r &   v  o i d 0  !== (e  =   r.g et ( t, "value")) ? e : " string" == ty  peof ( e = t.value ) ? e.replace( yt,   :  n ul  =    e  ? ""  :   e  : void  0  }  } ), S.exten d({ valHooks:  {  op t ion:  { get:  function(e) { var t =  S.find.att r( e,   "value ") ;  r e tu rn  null !=  t  ? t  ht(S.tex t (e))   }  },  s e le  ct : { get: func ti o n(e ) { var t, n,  r,  i = e.options, o = e.selectedIndex, a = "select -o ne" === e.type, s   = a  n  ul l  :  [],  u =  a   o  + 1  : i.len gth; for   (r = o < 0 ? u  :  a ? o : 0; r < u    r++)if  (((n = i[r ) se  cte ||     =  = =  o)   && !n.d isab led &  & (! n .p a re ntN ode.dis ab l   ||  ! A(n.paren tNode,   "op  t  grou p ")))  {  i f ( t  =  S(n).val(), a) return t; s. p ush(t) } r e turn s } ,  set: func t ion(e, t) { var n,  r, i  =  e.options, o  =  S.make A r ray(t ), a   = i.length ;   w hile (a-- )  (( r = i[ a]).sele c te d  = -1  < S . i nArray(S.valHooks. o ptio n .g et(r o   &&   (n   = !0) ;  return n || (e. selectedInde x  =  -1) ,  o } } }  } ) ,   S.each ([" radio",  "ch eckbox"], function()   { S. v alHooks[this] = { set: function(e, t) { if  ( Array.isArr a y(t)) return e.checked = -1 <   .i n Array(S(e). val ( ), t)  } }, y.chec k On || (S.va lH oo k s[this ].get =  fu nction(e )  {   return nul l  === e.ge tA tt r ib u t e("v a lu e") ? "on" : e.value  } ) } ) ,  y .focusin = "onfocusin" in C; var mt = /^(?:focusinfocus|focusoutblur ) $/, xt = functio n(e) { e.stopPropagati o n ( ) } ;   S. ex ten d( S .event, {  t rigger: function(e, t,  n ,  r ) { var  i , o ,  a , s, u,  l,  c, f, p = [n  || E], d =  v.call(e, "type" ) ? e. ty p e  : e, h =  v .call(e, "n am es p ace")  ?  e. n a mespa c e .split(".") : [ ]; if  (o   =  f  =   a = n = n || E,   3  !== n.nod eTyp e &&   8  ! ==   n .nodeTy p e  & & !mt.te st (d + S.e ve nt . triggere d )  && (-1  <  d.indexO f(". ")  && ( d  =  (h =  d.split(" .")).sh ift() ,  h.sort()), u = d.i n d e xOf(":") <  0 && "o n " + d, (e = e[S.expando] ? e : new S.Even t (d , "object"  ==  typeof e & &  e )).isTrigger = r  ?  2 : 3, e.nam e sp ace = h.join("." ),  e. rn ame spac e  = e.namespace ? new Reg E xp("(^|\\.) "  + h.join("\\.(?:.*\\.| )") + "(\\. | $)") : n ull , e.re sult = vo id  0, e.ta r g et || (e.t arget = n),  t  =   null = =  t  ?  [e ]  :   S.makeAr ray(t, [e]),   c  = S. e v ent .special [d]   ||  {}, r || !c.trig g er || !1 !==   c .trigger.ap p l y(n, t)) ) { if  ( ! r && !c. noBubble  && !x(n))  { f o r  (s = c. del eg at eT y pe   || d, mt.test(s +  d )  | |  ( o = o.parentNode);   o ; o = o . pa r entNode)p.pus h( o) ,   a = o; a ===  (n .ow nerD oc um e nt || E)  &&  p.push(a.de fault View  | | a.p ar entWin d ow ||   C) }  i  =  0; w hi le ((o  =  p[i++] )  && !e . isProp a gat ionStop ped( ) ) f = o, e.type  =   1 < i ?  s  :  c.bindType | | d, (l  = (Y.get(o ,  " events") || Object .create(null) )[e . t ype]   && Y.get(o, "handle") )  && l.apply(o, t), (l =  u  &&  o[ u]) &&  l . a pply &&  V(o) &&  ( e.result = l.apply(o, t),   !1   === e.result && e.preventD e f ault()); return e.type = d,  r  |   e.i  e  faultPrevent ed () || c._de f  ault && !1 != =  c . _def au lt.ap p l y (p.pop () ,    || ! V( n) || u  &  m( n[ d]) & &  !x(n )   & &  ( ( a = n[u] )   & & (n [u ] = n u ll ),  S.event .   iggered  = d, e .isPro p a ga t ionStopped()  && f.addEv entL i s t ener(d, xt), n [ d ](), e.isPropaga t i onStopped() &&  f .removeEventListen er(d,  x t) ,  S.e vent.t ri g ger ed = void 0, a &&  (n [u] = a) ),  e.result  } },  simula  t e : f u nction(e,   t,   n)  {  v a r r  = S.exten d( new   S.E     {  t yp e  :  e, isSim ulated: !0 }); S. even t.trig ge r(r, nul l, t) } }), S.fn.e xten d ({ tri g ger:  func t ion(e ,  t) { re turn this.ea ch(f uncti on() {   S.even t .tr i gger (e, t, this)  })  } ,  t riggerHandler : unct ion ( e, t)  {  v ar n = this[0]; i f  (n)  r eturn S.event.trig ger(e ,  t,  n, !0)  } } ), y.foc usin || S.ea c h ({ focus: "focu sin", bl ur :  "f o cus out" },  function(n,  r) { var i =  function(e ) { S.event.s im ulate(r, e. ta r get,  S .event.fix(e) ) } ;  S.event . special[r]  =  { setup: func tion() { va r  e  =  this. ow nerDo c u m e n t  ||  this.docu me nt   || this, t = Y. access (e,  r ); t ||  e .add E ventL i s tener(n, i,  ! 0), Y.access( e ,  r ,   ( t || 0) + 1) } ,  tea r d ow n:  f unction() { var e   = t his.ownerDocum ent || t his.documen t  | | this, t = Y . access(e, r) - 1; t  ? Y.access (e ,  r , t ) : (e.r e moveE ven tListener( n , i, !0), Y.remove ( e, r ) )  }  }  }); var  bt = C. location,  wt =  { guid:  D ate.now() } ,  T t = /\?/ ; S.pars eXML =  f un ction(e)  {  va r t, n;   i f  (!e || "str in g " != ty p eof e) retu rn   null;   try { t = (new C .D OM Pa rser).par se FromString ( e ,  " tex t/x m l" )  } c a t ch (e) {   } return n  = t && t.getE lementsByTa gN am e ("pars ererror")[0 ] ,  t  && !n || S.error(" I nvalid XM L :  "  + (n ? S.map(n.childNodes, functio n (e )   { r eturn e.te x tC o ntent }).join("\n" ) : e)), t }; var Ct = / \ [\] $/, Et = / \ r?\ n/g, St = /^(?: s ubm it|button| i mag e|reset|fi l e)$/ i , kt =  /^ ( ? :input|s el ec t |textarea| ke yg en )/ i;   f u n ction A t( n ,  e,  r, i) { var t; if (A rray.isArra y(e)) S.each(e,  function(e,  t) { r || Ct. test(n) ? i( n, t) : At( n  +  "[" +  ( "object" ==   typeof t && null  !=   t ?  e : "") + "] ", t,  r, i) });  el se   if (r || "object"  !==  w( e) )  i(n, e) ; else for  (t   in e) At(n + "[" +  t +  "] ",  e[t], r,  i) } S.par am  =  f u nction(e, t) { va r  n,  r  =  [], i = fu nction(e, t )  {  v ar n = m (t)  ? t() : t; r[r. l ength] = en codeU R IComponent( e )  + "="  +  e ncodeU RIComponent (n u ll == n ? "" : n) }; if (null == e) re tu rn   "";  if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function() { i(this.name, this.value) }); else for (n in e) At(n, e[n], t, i); return r.join("&") }, S.fn.extend({ serialize: function () { return  S . param(t h is.serializ eA r ray()) } ,  serializeArray:   function()  { re tu rn   this.map(functi o n()  { var   e = S.prop(this, "elements"); return  e ? S.m a keArray(e)  :  t his }) .f il te r(functio n( ) { var  e  =  t his.t y p e;   r etu rn th is.name  & & !S(this).is(":d isa bl e d") && kt. t est(this.nodeNam e)  && ! St.test(e) && (this.checked  || !pe. t est(e) )  }).ma p( function( e ,  t) { var n  =  S(this).va l ( ) ; return null   == n ? null  :  Array.is A rray(n) ? S.ma p(n, functi o n(e) { retu rn { name:   t. name, value:   e. replace(Et ,  " \r\n") } })   :  { name :  t .name ,  value: n .replace(Et ,  "\r\n") }  } ).get ( ) } }); va r Nt =  /%20/g,  jt  =  / #.*$/, D t =  / ([ ?&])_=[^ & ]*/, qt = /^(. *? ):[ \t ] *([^\r\n]*) $ /gm, Lt = / ^( ? : GE T |H E AD)$/, Ht = /^\ /\/ /,  Ot = {},  Pt  = {}, Rt = " */ ".concat(" *" ), Mt = E.create Ele ment("a");   function  It (o) {  r eturn fun ct i on(e , t) { "string" !=  t ypeof e &&  ( t = e, e =  "* " );  var   n, r   =  0, i = e .to L ow erCase(). m atch ( P)  || []; if  (m (t)) whi le  (n = i[r + +])   "+"   === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t) } } function Wt(t, i, o, a) { var s = {}, u = t === Pt; function l(e) { var r; return s[e] = !0, S.each(t[e] || [], function(e, t) { var n = t(i, o, a); return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1) }), r } return l(i.dataTypes[0]) || !s["*"] && l("*") } function Ft(e, t) { var n, r, i = S.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && S.extend(!0, e, r), e } Mt.href = bt.href, S.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: bt.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Rt, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": S.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function(e, t) { return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e) }, ajaxPrefilter: It(Ot), ajaxTransport: It(Pt), ajax: function(e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event, x = S.Deferred(), b = S.Callbacks("once memory"), w = v.statusCode || {}, a = {}, s = {}, u = "canceled", T = { readyState: 0, getResponseHeader: function(e) { var t; if (h) { if (!n) { n = {}; while (t = qt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]) } t = n[e.toLowerCase() + " "] } return null == t ? null : t.join(", ") }, getAllResponseHeaders: function() { return h ? p : null }, setRequestHeader: function(e, t) { return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this }, overrideMimeType: function(e) { return null == h && (v.mimeType = e), this }, statusCode: function(e) { var t; if (e) if (h) T.always(e[T.status]); else for (t in e) w[t] = [w[t], e[t]]; return this }, abort: function(e) { var t = e || u; return c && c.abort(t), l(0, t), this } }; if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) { r = E.createElement("a"); try { r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host } catch (e) { v.crossDomain = !0 } } if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T; for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]); if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort(); if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) { if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T; v.async && 0 < v.timeout && (d = C.setTimeout(function() { T.abort("timeout") }, v.timeout)); try { h = !1, c.send(a, l) } catch (e) { if (h) throw e; l(-1, e) } } else l(-1, "No Transport"); function l(e, t, n, r) { var i, o, a, s, u, l = t; h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function(e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function() { }), s = function(e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u; else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break } if (!0 !== a) if (a && e["throws"]) t = a(t); else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } } } return { state: "success", data: t } }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop"))) } return T }, getJSON: function(e, t, n) { return S.get(e, t, n, "json") }, getScript: function(e, t) { return S.get(e, void 0, t, "script") } }), S.each(["get", "post"], function(e, i) { S[i] = function(e, t, n, r) { return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({ url: e, type: i, dataType: r, data: t, success: n }, S.isPlainObject(e) && e)) } }), S.ajaxPrefilter(function(e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "") }), S._evalUrl = function(e, t, n) { return S.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function() { } }, dataFilter: function(e) { S.globalEval(e, t, n) } }) }, S.fn.extend({ wrapAll: function(e) { var t; return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function(n) { return m(n) ? this.each(function(e) { S(this).wrapInner(n.call(this, e)) }) : this.each(function() { var e = S(this), t = e.contents(); t.length ? t.wrapAll(n) : e.append(n) }) }, wrap: function(t) { var n = m(t); return this.each(function(e) { S(this).wrapAll(n ? t.call(this, e) : t) }) }, unwrap: function(e) { return this.parent(e).not("body").each(function() { S(this).replaceWith(this.childNodes) }), this } }), S.expr.pseudos.hidden = function(e) { return !S.expr.pseudos.visible(e) }, S.expr.pseudos.visible = function(e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, S.ajaxSettings.xhr = function() { try { return new C.XMLHttpRequest } catch (e) { } }; var Bt = { 0: 200, 1223: 204 }, $t = S.ajaxSettings.xhr(); y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function(i) { var o, a; if (y.cors || $t && !i.crossDomain) return { send: function(e, t) { var n, r = i.xhr(); if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n]; for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]); o = function(e) { return function() { o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? { binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())) } }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function() { 4 === r.readyState && C.setTimeout(function() { o && a() }) }, o = o("abort"); try { r.send(i.hasContent && i.data || null) } catch (e) { if (o) throw e } }, abort: function() { o && o() } } }), S.ajaxPrefilter(function(e) { e.crossDomain && (e.contents.script = !1) }), S.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function(e) { return S.globalEval(e), e } } }), S.ajaxPrefilter("script", function(e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), S.ajaxTransport("script", function(n) { var r, i; if (n.crossDomain || n.scriptAttrs) return { send: function(e, t) { r = S("<script>").attr(n.scriptAttrs || {}).prop({ charset: n.scriptCharset, src: n.url }).on("load error", i = function(e) { r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type) }), E.head.appendChild(r[0]) }, abort: function() { i && i() } } }); var _t, zt = [], Ut = /(=)\?(?=&|$)|\?\?/; S.ajaxSetup({ jsonp: "callback", jsonpCallback: function() { var e = zt.pop() || S.expando + "_" + wt.guid++; return this[e] = !0, e } }), S.ajaxPrefilter("json jsonp", function(e, t, n) { var r, i, o, a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data"); if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() { return o || S.error(r + " was not called"), o[0] }, e.dataTypes[0] = "json", i = C[r], C[r] = function() { o = arguments }, n.always(function() { void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0 }), "script" }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function(e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes))); var r, i, o }, S.fn.load = function(e, t, n) { var r, i, o, a = this, s = e.indexOf(" "); return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function(e) { o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e) }).always(n && function(e, t) { a.each(function() { n.apply(this, o || [e.responseText, t, e]) }) }), this }, S.expr.pseudos.animated = function(t) { return S.grep(S.timers, function(e) { return t === e.elem }).length }, S.offset = { setOffset: function(e, t, n) { var r, i, o, a, s, u, l = S.css(e, "position"), c = S(e), f = {}; "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f) } }, S.fn.extend({ offset: function(t) { if (arguments.length) return void 0 === t ? this : this.each(function(e) { S.offset.setOffset(this, t, e) }); var e, n, r = this[0]; return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function() { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0)) } return { top: t.top - i.top - S.css(r, "marginTop", !0), left: t.left - i.left - S.css(r, "marginLeft", !0) } } }, offsetParent: function() { return this.map(function() { var e = this.offsetParent; while (e && "static" === S.css(e, "position")) e = e.offsetParent; return e || re }) } }), S.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(t, i) { var o = "pageYOffset" === i; S.fn[t] = function(e) { return $(this, function(e, t, n) { var r; if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t]; r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n }, t, e, arguments.length) } }), S.each(["top", "left"], function(e, n) { S.cssHooks[n] = Fe(y.pixelPosition, function(e, t) { if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t }) }), S.each({ Height: "height", Width: "width" }, function(a, s) { S.each({ padding: "inner" + a, content: s, "": "outer" + a }, function(r, o) { S.fn[o] = function(e, t) { var n = arguments.length && (r || "boolean" != typeof e), i = r || (!0 === e || !0 === t ? "margin" : "border"); return $(this, function(e, t, n) { var r; return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i) }, s, n ? e : void 0, n) } }) }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) { S.fn[t] = function(e) { return this.on(t, e) } }), S.fn.extend({ bind: function(e, t, n) { return this.on(e, null, t, n) }, unbind: function(e, t) { return this.off(e, null, t) }, delegate: function(e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function(e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) }, hover: function(e, t) { return this.mouseenter(e).mouseleave(t || e) } }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, n) { S.fn[n] = function(e, t) { return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n) } }); var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; S.proxy = function(e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function() { return e.apply(t || this, r.concat(s.call(arguments))) }).guid = e.guid = e.guid || S.guid++, i }, S.holdReady = function(e) { e ? S.readyWait++ : S.ready(!0) }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function(e) { var t = S.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, S.trim = function(e) { return null == e ? "" : (e + "").replace(Xt, "") }, "function" == typeof define && define.amd && define("jquery", [], function() { return S }); var Vt = C.jQuery, Gt = C.$; return S.noConflict = function(e) { return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S }, "undefined" == typeof e && (C.jQuery = C.$ = S), S });
